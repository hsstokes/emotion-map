<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Joy - Emotional Experience</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #f7f7f7;
            font-family: 'Roboto Mono', monospace;
            -webkit-text-size-adjust: 100%;
            touch-action: none;
        }
        
        #landing-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(247, 247, 247, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            box-sizing: border-box;
            padding: 20px;
            transition: opacity 1s ease-in-out;
        }
        
        .landing-title {
            font-size: 24px;
            font-weight: 500;
            margin-bottom: 40px;
            text-align: center;
            letter-spacing: 1px;
        }
        
        .emotion-name {
            font-size: 36px;
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 3px;
            color: #FFD700;
        }
        
        .emotion-description {
            font-size: 14px;
            line-height: 1.4;
            max-width: 600px;
            text-align: center;
            margin-bottom: 30px;
            opacity: 0.8;
        }

        .ai-disclaimer {
           font-size: 13px;
           max-width: 550px;
           text-align: center;
           margin-bottom: 40px;
           margin-top: 10px;
           padding: 15px 20px;
           background-color: rgba(255, 215, 0, 0.1);
           border-radius: 8px;
           border-left: 3px solid #FFD700;
           line-height: 1.6;
           color: #333;
        }
        
        .start-button {
            padding: 15px 35px;
            background-color: rgba(255, 215, 0, 0.2);
            color: #333;
            border: 1px solid #FFD700;
            border-radius: 30px;
            font-family: 'Roboto Mono', monospace;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.3s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
        }
        
        .start-button:active {
            transform: scale(0.98);
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        .joy-resonance {
            position: fixed;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            padding: 15px;
            max-width: 250px;
            font-size: 13px;
            line-height: 1.4;
            color: #333;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            transform: translateY(20px);
            opacity: 0;
            transition: opacity 0.5s, transform 0.5s;
            pointer-events: none;
            z-index: 100;
            text-align: center;
            border-left: 3px solid #FFD700;
        }
        
        .controls {
            position: fixed;
            bottom: 15px;
            right: 15px;
            display: flex;
            gap: 10px;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        .control-button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            cursor: pointer;
        }
        
        .control-button svg {
            width: 20px;
            height: 20px;
            stroke: #FFD700;
        }
        
        .hint {
            position: fixed;
            bottom: 15px;
            left: 15px;
            background-color: rgba(255, 255, 255, 0.85);
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 12px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 50;
            color: #333;
        }
        
        .timeline {
            position: fixed;
            left: 50%;
            bottom: 20px;
            transform: translateX(-50%);
            width: 70%;
            max-width: 500px;
            height: 40px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            z-index: 40;
            opacity: 0;
            transition: opacity 0.5s;
            display: flex;
            align-items: center;
            padding: 0 15px;
        }
        
        .timeline-bar {
            width: 100%;
            height: 4px;
            background-color: rgba(255, 215, 0, 0.2);
            border-radius: 2px;
            position: relative;
        }
        
        .timeline-progress {
            height: 100%;
            background-color: rgba(255, 215, 0, 0.8);
            border-radius: 2px;
            width: 0%;
            transition: width 0.3s;
        }
        
        .timeline-handle {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background-color: #FFD700;
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            cursor: pointer;
        }
        
        @media (max-width: 768px) {
            body {
                overflow-y: auto !important;
                height: auto !important;
            }
        
            #landing-overlay {
                position: absolute;
                height: auto;
                min-height: 100%;
                overflow-y: auto;
                padding: 40px 20px 120px 20px;
                justify-content: flex-start;
            }
        
            .landing-title {
                margin-top: 40px;
            }
        
            .start-button {
                margin-bottom: 60px;
                position: relative;
            }
        
            .emotion-name {
                font-size: 42px;
            }
        
            .ai-disclaimer {
                width: 90%;
                font-size: 12px;
                max-width: 90%;
            }
        }
        
        @media screen and (orientation: portrait) {
            .controls {
                bottom: 70px;
                right: 15px;
            }
            
            .timeline {
                bottom: 20px;
                width: 80%;
            }
        }
        
        @media screen and (orientation: landscape) {
            .controls {
                bottom: 15px;
                right: 100px;
            }
            
            .timeline {
                bottom: 20px;
                width: 60%;
                max-width: 600px;
            }
        }
    </style>
</head>
<body>
    <div id="landing-overlay">
        <h1 class="landing-title">Emotional Collage Experience</h1>
        <h2 class="emotion-name" id="emotion-title">JOY</h2>
        <p class="emotion-description" id="emotion-description">
            An exploration of joy as a state of expansive energy radiating outward through networks of connectionâ€”warmth spreading like light through threads of belonging.
            <br><b>Analysis by Claude</b>
        </p>

        <div class="ai-disclaimer">
            <strong>Note:</strong> This is a simulation of joy based on my analysis of human descriptions. As an AI, I don't experience emotions or feelings - this is my interpretation of warmth, connection, and radiant expansion.
        </div>
        
        <button class="start-button" id="start-experience">Begin Experience</button>
    </div>
    
    <div class="joy-resonance" id="joy-resonance"></div>
    
    <div class="controls" id="controls">
        <div class="control-button" id="sound-toggle">
            <svg viewBox="0 0 24 24" fill="none" stroke-width="2">
                <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
                <path id="sound-waves" d="M15.54 8.46a5 5 0 0 1 0 7.07M19.07 4.93a10 10 0 0 1 0 14.14"></path>
            </svg>
        </div>
        <div class="control-button" id="reset-button">
            <svg viewBox="0 0 24 24" fill="none" stroke-width="2">
                <path d="M23 4v6h-6"></path>
                <path d="M1 20v-6h6"></path>
                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
            </svg>
        </div>
    </div>
    
    <div class="hint" id="hint">Touch elements to experience joy</div>
    
    <div class="timeline" id="timeline">
        <div class="timeline-bar" id="timeline-bar">
            <div class="timeline-progress" id="timeline-progress"></div>
            <div class="timeline-handle" id="timeline-handle"></div>
        </div>
    </div>
    
    <script>
        let isAnimating = true;
        let soundEnabled = true;
        let joySound;
        let soundLoaded = false;
        let timelineActive = false;
        let isDraggingTimeline = false;
        let timePosition = 0;
        let previousTimePosition = 0;
        let activatedTimeline = false;
        let energyPhase = 0;
        let energyRate = 0.4;
        
        // Joy particles flowing toward hand
        let joyParticles = [];
        
        // Texture points for stippled effect
        let texturePoints = [];
        
        // Thread connections (yarn-like organic lines)
        let threadConnections = [];
        
        // Satellite circles for abundance
        let satelliteCircles = [];
        
        // Sacred geometry overlapping circles
        let sacredGeometryCircles = [];
        
        const joyResonances = [
            "A warm glow of happiness spreading outward like morning light",
            "The quiet delight of discovering unexpected connections",
            "A sense of lightness and expansion filling the chest",
            "The resonant hum of deeply felt contentment",
            "A sparkle of pleasure radiating through every fiber",
            "The gentle lift that comes with genuine appreciation",
            "A burst of energy connecting you to everything around",
            "The dance between excitement and peaceful satisfaction",
            "A brightening sensation that makes everything clearer",
            "The flow state where everything feels possible",
            "A harmonious sense of being exactly where you belong",
            "The delightful lift when something resonates deeply",
            "Threads of warmth weaving through mind, body and spirit",
            "The soft radiance of being fully present in joy",
            "An upward spiral of positive feeling and connection",
            "Golden threads connecting hearts across distance",
            "The abundance of small moments gathered together",
            "Warmth spreading like sunlight through open hands"
        ];
        
        // Color palette for Joy - warmer golden yellow
        const colors = {
            yellow: [255, 215, 0],      // Golden yellow - Recognition
            yellowWarm: [255, 200, 50], // Warmer gold variant
            yellowLight: [255, 235, 130], // Light golden glow
            black: [0, 0, 0],           // Black - Evaluation
            grey: [128, 128, 128],      // Grey - Response
            greyLight: [180, 180, 180]  // Light grey for subtle elements
        };
        
        let recognitionElements = [];
        let evaluationElements = [];
        let responseElements = [];
        let connectionLines = [];
        let handOutlinePoints = [];
        let handProgress = 0;
        let joyCenters = [];
        let activeJoyCenter = null;
        let centerActivated = false;
        let timelineProgress = 0;
        
        function startExperience() {
            document.getElementById('landing-overlay').style.opacity = '0';
            
            setTimeout(() => {
                document.getElementById('landing-overlay').style.display = 'none';
                isAnimating = true;
                loop();
                updateLayoutForOrientation();
                
                if (soundEnabled && soundLoaded) {
                    try {
                        joySound.loop();
                        joySound.setVolume(0);
                        joySound.setVolume(0.6, 3);
                    } catch(e) {
                        console.error("Error playing sound:", e);
                    }
                }
                
                setTimeout(() => {
                    document.getElementById('controls').style.opacity = '1';
                    document.getElementById('hint').style.opacity = '1';
                    
                    setTimeout(() => {
                        document.getElementById('hint').style.opacity = '0';
                    }, 5000);
                }, 2000);
            }, 1000);
        }
        
        function updateLayoutForOrientation() {
            const controls = document.getElementById('controls');
            const timeline = document.getElementById('timeline');
            
            if (window.matchMedia("(orientation: portrait)").matches) {
                controls.style.bottom = "70px";
                controls.style.right = "15px";
                timeline.style.width = "80%";
            } else {
                controls.style.bottom = "15px";
                controls.style.right = "100px"; 
                timeline.style.width = "60%";
            }
        }
        
        window.addEventListener('orientationchange', function() {
            setTimeout(() => {
                resizeCanvas(windowWidth, windowHeight);
                repositionElements();
                updateLayoutForOrientation();
            }, 100);
        });
        
        document.getElementById('start-experience').addEventListener('click', startExperience);
        document.getElementById('start-experience').addEventListener('touchend', function(e) {
            e.preventDefault();
            startExperience();
        });
        
        document.getElementById('sound-toggle').addEventListener('click', function() {
            soundEnabled = !soundEnabled;
            document.getElementById('sound-waves').style.opacity = soundEnabled ? '1' : '0';
            
            if (soundEnabled && joySound && !joySound.isPlaying()) {
                joySound.loop();
                joySound.setVolume(0);
                joySound.setVolume(0.6, 2);
            } else if (!soundEnabled && joySound && joySound.isPlaying()) {
                joySound.setVolume(0, 2);
                setTimeout(() => {
                    joySound.pause();
                }, 2000);
            }
        });
        
        document.getElementById('reset-button').addEventListener('click', function() {
            timePosition = 0;
            previousTimePosition = 0;
            resetExperience();
            updateTimelineUI();
        });
        
        document.getElementById('timeline-bar').addEventListener('mousedown', startTimelineDrag);
        document.getElementById('timeline-bar').addEventListener('touchstart', startTimelineDrag);
        
        function startTimelineDrag(e) {
            if (e.type === 'touchstart') {
                e.preventDefault();
            }
            isDraggingTimeline = true;
            updateTimelinePosition(e);
            document.addEventListener('mousemove', updateTimelinePosition);
            document.addEventListener('touchmove', updateTimelinePosition, { passive: false });
            document.addEventListener('mouseup', endTimelineDrag);
            document.addEventListener('touchend', endTimelineDrag);
        }
        
        function updateTimelinePosition(e) {
            if (!isDraggingTimeline) return;
            if (e.type === 'touchmove') {
                e.preventDefault();
            }
            
            const timeline = document.getElementById('timeline-bar');
            const rect = timeline.getBoundingClientRect();
            let clientX;
            if (e.type.startsWith('touch')) {
                clientX = e.touches[0].clientX;
            } else {
                clientX = e.clientX;
            }
            
            let percentage = (clientX - rect.left) / rect.width;
            percentage = Math.max(0, Math.min(1, percentage));
            
            document.getElementById('timeline-progress').style.width = `${percentage * 100}%`;
            document.getElementById('timeline-handle').style.left = `${percentage * 100}%`;
            
            timePosition = percentage * 40000;
            setTimePosition(timePosition);
        }
        
        function endTimelineDrag() {
            isDraggingTimeline = false;
            document.removeEventListener('mousemove', updateTimelinePosition);
            document.removeEventListener('touchmove', updateTimelinePosition);
            document.removeEventListener('mouseup', endTimelineDrag);
            document.removeEventListener('touchend', endTimelineDrag);
            previousTimePosition = timePosition;
        }
        
        function updateTimelineUI() {
            const percentage = timePosition / 40000;
            document.getElementById('timeline-progress').style.width = `${percentage * 100}%`;
            document.getElementById('timeline-handle').style.left = `${percentage * 100}%`;
        }
        
        function preload() {
            soundLoaded = false;
            joySound = loadSound('joy_soundscape.mp3', 
                function() {
                    console.log("Sound loaded successfully");
                    soundLoaded = true;
                },
                function(err) {
                    console.error("Error loading sound:", err);
                    soundEnabled = false;
                }
            );
        }

        function setup() {
            createCanvas(windowWidth, windowHeight);
            
            createHandOutline();
            createRecognitionElements();
            createEvaluationElements();
            createResponseElements();
            createThreadConnections();
            createSatelliteCircles();
            createSacredGeometry();
            createTexturePoints();
            createJoyParticles();
            createJoyCenters();
            
            if (getAudioContext().state !== 'running') {
                getAudioContext().resume();
            }
            
            isAnimating = false;
            noLoop();
        }
        
        function getRandomResonance() {
            return joyResonances[floor(random(joyResonances.length))];
        }
        
        function createTexturePoints() {
            // Create stippled texture points for handmade quality
            for (let i = 0; i < 200; i++) {
                texturePoints.push({
                    x: random(width),
                    y: random(height),
                    size: random(1, 3),
                    opacity: random(20, 60),
                    type: random() > 0.5 ? 'yellow' : 'grey'
                });
            }
        }
        
        function createJoyParticles() {
            // Particles that flow toward the hand
            for (let i = 0; i < 30; i++) {
                let angle = random(TWO_PI);
                let distance = random(width * 0.3, width * 0.5);
                
                joyParticles.push({
                    x: width * 0.5 + cos(angle) * distance,
                    y: height * 0.5 + sin(angle) * distance,
                    originX: width * 0.5 + cos(angle) * distance,
                    originY: height * 0.5 + sin(angle) * distance,
                    size: random(3, 8),
                    speed: random(0.3, 0.8),
                    offset: random(TWO_PI),
                    opacity: random(100, 200),
                    active: false,
                    progress: 0
                });
            }
        }
        
        function createThreadConnections() {
            // Create organic yarn-like thread connections
            for (let i = 0; i < 12; i++) {
                let startAngle = random(TWO_PI);
                let endAngle = startAngle + random(PI * 0.3, PI * 0.8);
                let startDist = random(width * 0.15, width * 0.25);
                let endDist = random(width * 0.25, width * 0.4);
                
                let startX = width * 0.5 + cos(startAngle) * startDist;
                let startY = height * 0.5 + sin(startAngle) * startDist;
                let endX = width * 0.5 + cos(endAngle) * endDist;
                let endY = height * 0.5 + sin(endAngle) * endDist;
                
                // Create wavy control points
                let numPoints = floor(random(4, 7));
                let points = [];
                
                for (let j = 0; j <= numPoints; j++) {
                    let t = j / numPoints;
                    let baseX = lerp(startX, endX, t);
                    let baseY = lerp(startY, endY, t);
                    
                    // Add wave offset
                    let waveOffset = sin(t * PI * 2) * random(15, 35);
                    let perpAngle = atan2(endY - startY, endX - startX) + HALF_PI;
                    
                    points.push({
                        x: baseX + cos(perpAngle) * waveOffset,
                        y: baseY + sin(perpAngle) * waveOffset
                    });
                }
                
                threadConnections.push({
                    points: points,
                    width: random(1.5, 3),
                    opacity: random(80, 150),
                    startTime: 3000 + i * 500,
                    progress: 0,
                    wavePhase: random(TWO_PI),
                    waveSpeed: random(0.001, 0.003)
                });
            }
        }
        
        function createSatelliteCircles() {
            // Create abundant satellite circles around main elements
            for (let i = 0; i < 40; i++) {
                let angle = random(TWO_PI);
                let distance = random(width * 0.1, width * 0.45);
                
                satelliteCircles.push({
                    x: width * 0.5 + cos(angle) * distance,
                    y: height * 0.5 + sin(angle) * distance,
                    size: random(4, 15),
                    opacity: random(60, 140),
                    startTime: 2000 + i * 150,
                    visible: false,
                    pulseOffset: random(TWO_PI),
                    pulseSpeed: random(0.001, 0.003),
                    orbitRadius: random(3, 10),
                    orbitSpeed: random(0.0005, 0.002),
                    orbitOffset: random(TWO_PI)
                });
            }
        }
        
        function createSacredGeometry() {
            // Create flower of life / overlapping circles pattern
            let centerX = width * 0.5;
            let centerY = height * 0.5;
            let baseRadius = min(width, height) * 0.12;
            
            // Central circle
            sacredGeometryCircles.push({
                x: centerX,
                y: centerY,
                radius: baseRadius,
                opacity: 80,
                startTime: 8000
            });
            
            // First ring of 6 circles
            for (let i = 0; i < 6; i++) {
                let angle = TWO_PI * i / 6;
                sacredGeometryCircles.push({
                    x: centerX + cos(angle) * baseRadius,
                    y: centerY + sin(angle) * baseRadius,
                    radius: baseRadius,
                    opacity: 60,
                    startTime: 9000 + i * 200
                });
            }
            
            // Second ring of 12 circles
            for (let i = 0; i < 12; i++) {
                let angle = TWO_PI * i / 12 + PI / 12;
                sacredGeometryCircles.push({
                    x: centerX + cos(angle) * baseRadius * 1.73,
                    y: centerY + sin(angle) * baseRadius * 1.73,
                    radius: baseRadius,
                    opacity: 40,
                    startTime: 11000 + i * 150
                });
            }
        }
        
        function createRecognitionElements() {
            // Enhanced sunburst with longer rays and golden glow
            recognitionElements.push({
                type: 'sunburst',
                x: width * 0.5,
                y: height * 0.5,
                size: height * 0.18,
                rays: 16,
                rayLength: 1.8,
                opacity: 220,
                startTime: 500,
                visible: false,
                interactive: true,
                activated: false,
                activatedTime: 0,
                energy: 0,
                maxEnergy: 100,
                energyRate: 0.03,
                pulseRate: 0.0006,
                glowSize: 1.3
            });
            
            // Network nodes with more abundance
            for (let i = 0; i < 10; i++) {
                let angle = TWO_PI * i / 10 + random(-0.2, 0.2);
                let distance = random(width * 0.12, width * 0.32);
                let x = width * 0.5 + cos(angle) * distance;
                let y = height * 0.5 + sin(angle) * distance;
                
                recognitionElements.push({
                    type: 'node',
                    x: x,
                    y: y,
                    size: random(12, 28),
                    opacity: random(160, 220),
                    startTime: 1000 + i * 300,
                    visible: false,
                    interactive: random() > 0.3,
                    activated: false,
                    activatedTime: 0,
                    energy: 0,
                    maxEnergy: random(70, 100),
                    energyRate: random(0.02, 0.04),
                    pulseRate: random(0.0005, 0.001),
                    satellites: floor(random(2, 5))
                });
            }
            
            // Circular patterns with concentric rings
            for (let i = 0; i < 6; i++) {
                recognitionElements.push({
                    type: 'circle',
                    x: width * (0.25 + random(0.5)),
                    y: height * (0.25 + random(0.5)),
                    size: random(35, 80),
                    rings: floor(random(3, 6)),
                    opacity: random(140, 200),
                    startTime: 2500 + i * 400,
                    visible: false,
                    interactive: random() > 0.3,
                    activated: false,
                    activatedTime: 0,
                    energy: 0,
                    maxEnergy: random(60, 100),
                    energyRate: random(0.02, 0.04),
                    pulseRate: random(0.0005, 0.001)
                });
            }
            
            // Hexagonal elements
            for (let i = 0; i < 4; i++) {
                recognitionElements.push({
                    type: 'hexagon',
                    x: width * (0.2 + random(0.6)),
                    y: height * (0.2 + random(0.6)),
                    size: random(22, 45),
                    opacity: random(160, 220),
                    startTime: 3500 + i * 500,
                    visible: false,
                    interactive: random() > 0.4,
                    activated: false,
                    activatedTime: 0,
                    energy: 0,
                    maxEnergy: random(70, 100),
                    energyRate: random(0.02, 0.04),
                    pulseRate: random(0.0005, 0.001),
                    rotation: random(TWO_PI)
                });
            }
        }
        
        function createEvaluationElements() {
            // Frames with organic feel
            for (let i = 0; i < 5; i++) {
                evaluationElements.push({
                    type: 'frame',
                    x: width * (0.25 + random(0.5)),
                    y: height * (0.25 + random(0.5)),
                    width: random(45, 90),
                    height: random(45, 90),
                    thickness: random(1.5, 2.5),
                    opacity: random(150, 200),
                    startTime: 4500 + i * 600,
                    visible: false,
                    interactive: true,
                    activated: false,
                    activatedTime: 0,
                    intensity: 0,
                    maxIntensity: 100,
                    intensityRate: random(0.02, 0.04),
                    pulseRate: random(0.0005, 0.001)
                });
            }
            
            // Boundary points
            for (let i = 0; i < 8; i++) {
                evaluationElements.push({
                    type: 'point',
                    x: width * (0.15 + random(0.7)),
                    y: height * (0.15 + random(0.7)),
                    size: random(5, 12),
                    opacity: random(180, 230),
                    startTime: 5500 + i * 400,
                    visible: false,
                    interactive: random() > 0.4,
                    activated: false,
                    activatedTime: 0,
                    intensity: 0,
                    maxIntensity: random(80, 100),
                    intensityRate: random(0.02, 0.04),
                    pulseRate: random(0.0005, 0.001)
                });
            }
            
            // Negative space elements
            for (let i = 0; i < 3; i++) {
                evaluationElements.push({
                    type: 'negative',
                    x: width * (0.3 + random(0.4)),
                    y: height * (0.3 + random(0.4)),
                    size: random(55, 100),
                    opacity: random(140, 190),
                    startTime: 7000 + i * 800,
                    visible: false,
                    interactive: random() > 0.3,
                    activated: false,
                    activatedTime: 0,
                    intensity: 0,
                    maxIntensity: random(70, 100),
                    intensityRate: random(0.02, 0.04),
                    pulseRate: random(0.0005, 0.001)
                });
            }
        }
        
        function createResponseElements() {
            // Connector nodes
            for (let i = 0; i < 6; i++) {
                let angle = random(TWO_PI);
                let distance = random(width * 0.2, width * 0.38);
                let x = width * 0.5 + cos(angle) * distance;
                let y = height * 0.5 + sin(angle) * distance;
                
                responseElements.push({
                    type: 'connector',
                    x: x,
                    y: y,
                    size: random(18, 30),
                    opacity: random(160, 210),
                    startTime: 9000 + i * 600,
                    visible: false,
                    interactive: true,
                    activated: false,
                    activatedTime: 0,
                    harmony: 0,
                    maxHarmony: random(80, 100),
                    harmonyRate: random(0.02, 0.04),
                    pulseRate: random(0.0005, 0.001)
                });
            }
            
            // Flowing paths
            for (let i = 0; i < 5; i++) {
                let startAngle = random(TWO_PI);
                let startDist = random(width * 0.15, width * 0.25);
                let endDist = random(width * 0.3, width * 0.42);
                
                let startX = width * 0.5 + cos(startAngle) * startDist;
                let startY = height * 0.5 + sin(startAngle) * startDist;
                let endX = width * 0.5 + cos(startAngle + random(0.3, 0.8)) * endDist;
                let endY = height * 0.5 + sin(startAngle + random(0.3, 0.8)) * endDist;
                
                let points = [];
                points.push({x: startX, y: startY});
                
                let controlX1 = lerp(startX, endX, 0.3) + random(-50, 50);
                let controlY1 = lerp(startY, endY, 0.3) + random(-50, 50);
                let controlX2 = lerp(startX, endX, 0.7) + random(-50, 50);
                let controlY2 = lerp(startY, endY, 0.7) + random(-50, 50);
                
                points.push({x: controlX1, y: controlY1});
                points.push({x: controlX2, y: controlY2});
                points.push({x: endX, y: endY});
                
                responseElements.push({
                    type: 'path',
                    points: points,
                    width: random(2, 4),
                    opacity: random(130, 170),
                    startTime: 11000 + i * 800,
                    visible: false,
                    interactive: true,
                    activated: false,
                    activatedTime: 0,
                    harmony: 0,
                    maxHarmony: random(80, 100),
                    harmonyRate: random(0.02, 0.04),
                    pulseRate: random(0.0005, 0.001),
                    progress: 0
                });
            }
            
            // Integration mandala elements
            for (let i = 0; i < 4; i++) {
                responseElements.push({
                    type: 'integration',
                    x: width * (0.25 + random(0.5)),
                    y: height * (0.25 + random(0.5)),
                    size: random(50, 85),
                    petals: floor(random(6, 10)),
                    opacity: random(120, 160),
                    startTime: 14000 + i * 1000,
                    visible: false,
                    interactive: random() > 0.3,
                    activated: false,
                    activatedTime: 0,
                    harmony: 0,
                    maxHarmony: random(70, 100),
                    harmonyRate: random(0.02, 0.04),
                    pulseRate: random(0.0005, 0.001),
                    rotation: 0,
                    rotationSpeed: random(0.0001, 0.0004)
                });
            }
        }

        function createHandOutline() {
            // Open receiving hand
            handOutlinePoints.push({x: 0.46, y: 0.68});
            handOutlinePoints.push({x: 0.64, y: 0.68});
            handOutlinePoints.push({x: 0.68, y: 0.62});
            handOutlinePoints.push({x: 0.70, y: 0.54});
            handOutlinePoints.push({x: 0.68, y: 0.46});
            handOutlinePoints.push({x: 0.64, y: 0.40});
            handOutlinePoints.push({x: 0.60, y: 0.36});
            handOutlinePoints.push({x: 0.55, y: 0.33});
            handOutlinePoints.push({x: 0.50, y: 0.32});
            handOutlinePoints.push({x: 0.45, y: 0.33});
            handOutlinePoints.push({x: 0.40, y: 0.36});
            handOutlinePoints.push({x: 0.36, y: 0.40});
            handOutlinePoints.push({x: 0.32, y: 0.46});
            handOutlinePoints.push({x: 0.30, y: 0.54});
            handOutlinePoints.push({x: 0.32, y: 0.62});
            handOutlinePoints.push({x: 0.46, y: 0.68});
            
            for (let i = 0; i < handOutlinePoints.length; i++) {
                handOutlinePoints[i].x *= width;
                handOutlinePoints[i].y *= height;
            }
        }
        
        function createJoyCenters() {
            // Main central joy center
            joyCenters.push({
                x: width * 0.5, 
                y: height * 0.5,
                size: 100,
                opacity: 0,
                targetOpacity: 200,
                pulseRate: 0.0006,
                activated: false,
                activationProgress: 0,
                startTime: 16000,
                resonance: "A warm glow of happiness spreading outward like sunlight through golden threads",
                elements: []
            });
            
            // Secondary joy centers
            for (let i = 0; i < 3; i++) {
                let angle = TWO_PI * i / 3 + random(-0.3, 0.3);
                let dist = random(width * 0.2, width * 0.3);
                
                joyCenters.push({
                    x: width * 0.5 + cos(angle) * dist,
                    y: height * 0.5 + sin(angle) * dist,
                    size: random(55, 75),
                    opacity: 0,
                    targetOpacity: random(150, 200),
                    pulseRate: random(0.0004, 0.0008),
                    activated: false,
                    activationProgress: 0,
                    startTime: 20000 + i * 3000,
                    resonance: getRandomResonance(),
                    elements: []
                });
            }
            
            // Assign elements to joy centers
            for (let i = 0; i < recognitionElements.length; i++) {
                let recognition = recognitionElements[i];
                let closestCenter = null;
                let closestDistance = Infinity;
                
                for (let j = 0; j < joyCenters.length; j++) {
                    let d = dist(recognition.x, recognition.y, joyCenters[j].x, joyCenters[j].y);
                    if (d < closestDistance && d < 220) {
                        closestDistance = d;
                        closestCenter = j;
                    }
                }
                
                if (closestCenter !== null) {
                    joyCenters[closestCenter].elements.push({
                        type: 'recognition',
                        index: i
                    });
                }
            }
            
            for (let i = 0; i < evaluationElements.length; i++) {
                let evaluation = evaluationElements[i];
                let closestCenter = null;
                let closestDistance = Infinity;
                
                for (let j = 0; j < joyCenters.length; j++) {
                    let d = dist(evaluation.x, evaluation.y, joyCenters[j].x, joyCenters[j].y);
                    if (d < closestDistance && d < 190) {
                        closestDistance = d;
                        closestCenter = j;
                    }
                }
                
                if (closestCenter !== null) {
                    joyCenters[closestCenter].elements.push({
                        type: 'evaluation',
                        index: i
                    });
                }
            }
            
            for (let i = 0; i < responseElements.length; i++) {
                let response = responseElements[i];
                if (response.type !== 'path') {
                    let closestCenter = null;
                    let closestDistance = Infinity;
                    
                    for (let j = 0; j < joyCenters.length; j++) {
                        let d = dist(response.x, response.y, joyCenters[j].x, joyCenters[j].y);
                        if (d < closestDistance && d < 200) {
                            closestDistance = d;
                            closestCenter = j;
                        }
                    }
                    
                    if (closestCenter !== null) {
                        joyCenters[closestCenter].elements.push({
                            type: 'response',
                            index: i
                        });
                    }
                }
            }
        }

        function draw() {
            background(247, 247, 247);
            
            if (isAnimating && !isDraggingTimeline) {
                timePosition += deltaTime * 0.7;
                
                if (timePosition > 40000) {
                    timePosition = 40000;
                    if (!activatedTimeline) {
                        showTimeline();
                        activatedTimeline = true;
                    }
                }
                
                updateTimelineUI();
                previousTimePosition = timePosition;
            }

            energyPhase += energyRate * deltaTime * 0.001;
            
            // Draw layers in order
            drawTexturePoints();
            drawSacredGeometry();
            drawSatelliteCircles();
            drawRecognitionElements();
            drawThreadConnections();
            drawEvaluationElements();
            drawResponseElements();
            drawHandOutline();
            drawJoyParticles();
            drawJoyCenters();
            
            if (isAnimating) {
                handProgress = min(1, handProgress + 0.0002);
            }
            
            updateActivatedElements();
            updateElementPropagation();
            updateJoyParticles();
        }
        
        function drawTexturePoints() {
            // Draw stippled texture for handmade quality
            noStroke();
            
            for (let point of texturePoints) {
                if (point.type === 'yellow') {
                    fill(colors.yellow[0], colors.yellow[1], colors.yellow[2], point.opacity);
                } else {
                    fill(colors.grey[0], colors.grey[1], colors.grey[2], point.opacity);
                }
                ellipse(point.x, point.y, point.size);
            }
        }
        
        function drawSacredGeometry() {
            // Draw flower of life pattern
            noFill();
            
            for (let circle of sacredGeometryCircles) {
                if (timePosition > circle.startTime) {
                    let fadeIn = min(1, (timePosition - circle.startTime) / 2000);
                    
                    stroke(colors.grey[0], colors.grey[1], colors.grey[2], circle.opacity * fadeIn);
                    strokeWeight(1);
                    
                    // Add gentle pulse
                    let pulse = 1 + sin(millis() * 0.0005 + circle.x * 0.01) * 0.03;
                    
                    ellipse(circle.x, circle.y, circle.radius * 2 * pulse);
                }
            }
        }
        
        function drawSatelliteCircles() {
            // Draw abundant satellite circles
            noStroke();
            
            for (let sat of satelliteCircles) {
                if (timePosition > sat.startTime) {
                    sat.visible = true;
                    
                    // Calculate orbit position
                    let orbitAngle = millis() * sat.orbitSpeed + sat.orbitOffset;
                    let orbitX = sat.x + cos(orbitAngle) * sat.orbitRadius;
                    let orbitY = sat.y + sin(orbitAngle) * sat.orbitRadius;
                    
                    // Pulse effect
                    let pulse = 1 + sin(millis() * sat.pulseSpeed + sat.pulseOffset) * 0.15;
                    
                    fill(colors.yellow[0], colors.yellow[1], colors.yellow[2], sat.opacity);
                    ellipse(orbitX, orbitY, sat.size * pulse);
                    
                    // Add small halo
                    noFill();
                    stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], sat.opacity * 0.3);
                    strokeWeight(0.5);
                    ellipse(orbitX, orbitY, sat.size * pulse * 1.5);
                }
            }
        }
        
        function drawThreadConnections() {
            // Draw organic yarn-like thread connections
            for (let thread of threadConnections) {
                if (timePosition > thread.startTime) {
                    // Update progress
                    if (thread.progress < 1) {
                        thread.progress = min(1, thread.progress + 0.003);
                    }
                    
                    // Calculate wave animation
                    let wavePhase = millis() * thread.waveSpeed + thread.wavePhase;
                    
                    // Draw flowing thread
                    noFill();
                    stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], thread.opacity);
                    strokeWeight(thread.width);
                    
                    beginShape();
                    for (let i = 0; i < thread.points.length * thread.progress; i++) {
                        let point = thread.points[floor(i)];
                        
                        // Add wave motion
                        let waveOffset = sin(wavePhase + i * 0.5) * 3;
                        let perpAngle = 0;
                        
                        if (i > 0 && i < thread.points.length - 1) {
                            let prev = thread.points[i - 1];
                            let next = thread.points[min(i + 1, thread.points.length - 1)];
                            perpAngle = atan2(next.y - prev.y, next.x - prev.x) + HALF_PI;
                        }
                        
                        curveVertex(
                            point.x + cos(perpAngle) * waveOffset,
                            point.y + sin(perpAngle) * waveOffset
                        );
                    }
                    endShape();
                    
                    // Add texture dots along thread
                    if (thread.progress > 0.5) {
                        noStroke();
                        fill(colors.yellowLight[0], colors.yellowLight[1], colors.yellowLight[2], thread.opacity * 0.6);
                        
                        for (let i = 0; i < thread.points.length * thread.progress; i += 2) {
                            let point = thread.points[floor(i)];
                            ellipse(point.x, point.y, 2);
                        }
                    }
                }
            }
        }
        
        function drawJoyParticles() {
            // Draw particles flowing toward hand when joy centers are active
            if (activeJoyCenter !== null && joyCenters[activeJoyCenter].activationProgress > 0.3) {
                let handCenterX = width * 0.5;
                let handCenterY = height * 0.5;
                
                for (let particle of joyParticles) {
                    if (!particle.active && random() > 0.98) {
                        particle.active = true;
                        particle.progress = 0;
                    }
                    
                    if (particle.active) {
                        particle.progress += particle.speed * 0.01;
                        
                        if (particle.progress >= 1) {
                            particle.active = false;
                            particle.progress = 0;
                            // Reset to new position
                            let angle = random(TWO_PI);
                            let distance = random(width * 0.3, width * 0.5);
                            particle.originX = handCenterX + cos(angle) * distance;
                            particle.originY = handCenterY + sin(angle) * distance;
                        }
                        
                        // Calculate current position with spiral motion
                        let t = particle.progress;
                        let spiralOffset = sin(t * PI * 4 + particle.offset) * 20 * (1 - t);
                        
                        let currentX = lerp(particle.originX, handCenterX, t);
                        let currentY = lerp(particle.originY, handCenterY, t);
                        
                        // Add spiral motion
                        let angle = atan2(handCenterY - particle.originY, handCenterX - particle.originX) + HALF_PI;
                        currentX += cos(angle) * spiralOffset;
                        currentY += sin(angle) * spiralOffset;
                        
                        // Draw particle with glow
                        let alpha = particle.opacity * (1 - t * 0.5) * joyCenters[activeJoyCenter].activationProgress;
                        
                        // Outer glow
                        noStroke();
                        fill(colors.yellowLight[0], colors.yellowLight[1], colors.yellowLight[2], alpha * 0.3);
                        ellipse(currentX, currentY, particle.size * 2);
                        
                        // Core
                        fill(colors.yellow[0], colors.yellow[1], colors.yellow[2], alpha);
                        ellipse(currentX, currentY, particle.size * (1 - t * 0.5));
                    }
                }
            }
        }
        
        function updateJoyParticles() {
            // Activate particles when joy centers are active
            if (activeJoyCenter !== null) {
                for (let particle of joyParticles) {
                    if (!particle.active && random() > 0.97) {
                        particle.active = true;
                    }
                }
            }
        }
        
        function showTimeline() {
            document.getElementById('timeline').style.opacity = '1';
            updateLayoutForOrientation();
        }
        
        function updateActivatedElements() {
            for (let recognition of recognitionElements) {
                if (recognition.activated) {
                    if (recognition.energy > 0) {
                        recognition.energy = max(0, recognition.energy - 0.15);
                    }
                    if (millis() - recognition.activatedTime > 6000) {
                        recognition.activated = false;
                    }
                }
            }
            
            for (let evaluation of evaluationElements) {
                if (evaluation.activated) {
                    if (evaluation.intensity > 0) {
                        evaluation.intensity = max(0, evaluation.intensity - 0.15);
                    }
                    if (millis() - evaluation.activatedTime > 6000) {
                        evaluation.activated = false;
                    }
                }
            }
            
            for (let response of responseElements) {
                if (response.activated) {
                    if (response.harmony > 0) {
                        response.harmony = max(0, response.harmony - 0.15);
                    }
                    if (millis() - response.activatedTime > 6000) {
                        response.activated = false;
                    }
                }
            }
            
            for (let center of joyCenters) {
                if (center.activated) {
                    center.activationProgress = min(1, center.activationProgress + 0.004);
                }
            }
            
            if (activeJoyCenter !== null && !joyCenters[activeJoyCenter].activated) {
                if (joyCenters[activeJoyCenter].activationProgress > 0) {
                    joyCenters[activeJoyCenter].activationProgress = max(0, joyCenters[activeJoyCenter].activationProgress - 0.008);
                } else {
                    activeJoyCenter = null;
                    centerActivated = false;
                }
            }
        }
        
        function updateElementPropagation() {
            // Spreading joy between elements
            for (let i = 0; i < recognitionElements.length; i++) {
                let recognition = recognitionElements[i];
                
                if (recognition.activated && recognition.energy > 25) {
                    for (let j = 0; j < evaluationElements.length; j++) {
                        let evaluation = evaluationElements[j];
                        let d = dist(recognition.x, recognition.y, evaluation.x, evaluation.y);
                        
                        if (d < 220) {
                            let intensityTransfer = max(0, recognition.energy * (1 - d/220) * 0.08);
                            evaluation.intensity = min(evaluation.maxIntensity, evaluation.intensity + intensityTransfer);
                            
                            if (evaluation.intensity > 20 && !evaluation.activated) {
                                evaluation.activated = true;
                                evaluation.activatedTime = millis();
                            }
                        }
                    }
                }
            }
            
            for (let i = 0; i < evaluationElements.length; i++) {
                let evaluation = evaluationElements[i];
                
                if (evaluation.activated && evaluation.intensity > 30) {
                    for (let j = 0; j < responseElements.length; j++) {
                        let response = responseElements[j];
                        
                        if (response.type !== 'path') {
                            let d = dist(evaluation.x, evaluation.y, response.x, response.y);
                            
                            if (d < 220) {
                                let harmonyTransfer = max(0, evaluation.intensity * (1 - d/220) * 0.06);
                                response.harmony = min(response.maxHarmony, response.harmony + harmonyTransfer);
                                
                                if (response.harmony > 25 && !response.activated) {
                                    response.activated = true;
                                    response.activatedTime = millis();
                                }
                            }
                        }
                    }
                }
            }
            
            // Joy feedback loop
            for (let i = 0; i < responseElements.length; i++) {
                let response = responseElements[i];
                
                if (response.activated) {
                    let harmonyValue = response.harmony;
                    
                    if (harmonyValue > 35) {
                        for (let j = 0; j < recognitionElements.length; j++) {
                            let recognition = recognitionElements[j];
                            let d = dist(response.x, response.y, recognition.x, recognition.y);
                            
                            if (d < 220) {
                                let energyTransfer = max(0, harmonyValue * (1 - d/220) * 0.05);
                                recognition.energy = min(recognition.maxEnergy, recognition.energy + energyTransfer);
                                
                                if (recognition.energy > 20 && !recognition.activated) {
                                    recognition.activated = true;
                                    recognition.activatedTime = millis();
                                }
                            }
                        }
                    }
                }
            }
        }
        
        function setTimePosition(time) {
            const previousMillis = previousTimePosition;
            const timeDiff = time - previousMillis;
            
            if (timeDiff < -2000) {
                resetExperience();
            }
        }
        
        function resetExperience() {
            for (let recognition of recognitionElements) {
                recognition.visible = timePosition > recognition.startTime;
                recognition.activated = false;
                recognition.energy = 0;
            }
            
            for (let evaluation of evaluationElements) {
                evaluation.visible = timePosition > evaluation.startTime;
                evaluation.activated = false;
                evaluation.intensity = 0;
            }
            
            for (let response of responseElements) {
                response.visible = timePosition > response.startTime;
                response.activated = false;
                response.harmony = 0;
                
                if (response.type === 'path') {
                    response.progress = 0;
                }
                if (response.type === 'integration') {
                    response.rotation = 0;
                }
            }
            
            for (let thread of threadConnections) {
                thread.progress = 0;
            }
            
            for (let center of joyCenters) {
                center.opacity = timePosition > center.startTime ? center.targetOpacity : 0;
                center.activated = false;
                center.activationProgress = 0;
            }
            
            for (let particle of joyParticles) {
                particle.active = false;
                particle.progress = 0;
            }
            
            handProgress = min(1, timePosition / 35000);
            activeJoyCenter = null;
            centerActivated = false;
        }

        function drawHandOutline() {
            if (timePosition < 12000) return;
            
            let pointsToShow = floor(handOutlinePoints.length * handProgress);
            if (pointsToShow < 2) return;
            
            // Draw the hand outline with warmth
            noFill();
            stroke(colors.grey[0], colors.grey[1], colors.grey[2], 120);
            strokeWeight(1.5);
            
            beginShape();
            for (let i = 0; i < pointsToShow; i++) {
                vertex(handOutlinePoints[i].x, handOutlinePoints[i].y);
            }
            endShape(pointsToShow === handOutlinePoints.length ? CLOSE : OPEN);
            
            // Interior details when complete
            if (pointsToShow === handOutlinePoints.length) {
                // Palm lines
                stroke(colors.grey[0], colors.grey[1], colors.grey[2], 80);
                strokeWeight(1);
                
                // Heart line
                let lineY = (handOutlinePoints[0].y + handOutlinePoints[8].y) / 2;
                beginShape();
                curveVertex(handOutlinePoints[14].x + 10, lineY);
                curveVertex(handOutlinePoints[14].x + 10, lineY);
                curveVertex(width * 0.5, lineY - 5);
                curveVertex(handOutlinePoints[2].x - 10, lineY);
                curveVertex(handOutlinePoints[2].x - 10, lineY);
                endShape();
                
                // Life line
                beginShape();
                curveVertex(handOutlinePoints[14].x, handOutlinePoints[14].y - 20);
                curveVertex(handOutlinePoints[14].x + 5, handOutlinePoints[14].y - 30);
                curveVertex(handOutlinePoints[11].x + 10, handOutlinePoints[11].y + 15);
                curveVertex(handOutlinePoints[11].x + 15, handOutlinePoints[11].y + 25);
                endShape();
                
                // Joy symbol in palm when activated
                if (activeJoyCenter !== null && joyCenters[activeJoyCenter].activationProgress > 0.4) {
                    let centerX = width * 0.5;
                    let centerY = (handOutlinePoints[0].y + handOutlinePoints[8].y) / 2;
                    
                    let energyFactor = sin(energyPhase) * 0.1 + 0.95;
                    let activation = joyCenters[activeJoyCenter].activationProgress;
                    
                    push();
                    translate(centerX, centerY);
                    
                    // Radiating glow
                    for (let r = 3; r > 0; r--) {
                        noFill();
                        stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], 
                              40 * activation * (4 - r) / 3);
                        strokeWeight(1);
                        ellipse(0, 0, (20 + r * 10) * energyFactor * activation);
                    }
                    
                    // Sunburst rays
                    stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], 180 * activation);
                    strokeWeight(1.5);
                    
                    let numRays = 16;
                    for (let i = 0; i < numRays; i++) {
                        let angle = TWO_PI * i / numRays + millis() * 0.0001;
                        let innerRadius = 8 * energyFactor * activation;
                        let outerRadius = 18 * energyFactor * activation;
                        
                        line(cos(angle) * innerRadius, sin(angle) * innerRadius,
                             cos(angle) * outerRadius, sin(angle) * outerRadius);
                    }
                    
                    // Center circle
                    fill(colors.yellow[0], colors.yellow[1], colors.yellow[2], 200 * activation);
                    noStroke();
                    ellipse(0, 0, 12 * energyFactor * activation);
                    
                    pop();
                }
            }
        }
        
        function drawRecognitionElements() {
            for (let i = 0; i < recognitionElements.length; i++) {
                let recognition = recognitionElements[i];
                
                if (timePosition > recognition.startTime) {
                    recognition.visible = true;
                }
                
                if (recognition.visible) {
                    let pulseAmount = sin(millis() * recognition.pulseRate) * 0.08;
                    
                    let energyFactor = 0;
                    if (recognition.activated || recognition.energy > 0) {
                        energyFactor = recognition.energy / recognition.maxEnergy;
                        
                        // Draw energy glow with golden halo
                        noFill();
                        for (let g = 3; g > 0; g--) {
                            stroke(colors.yellowLight[0], colors.yellowLight[1], colors.yellowLight[2], 
                                  50 * energyFactor * g / 3);
                            strokeWeight(2);
                            
                            if (recognition.type === 'sunburst') {
                                ellipse(recognition.x, recognition.y, 
                                       recognition.size * (recognition.glowSize + g * 0.1 + energyFactor * 0.2));
                            } else {
                                ellipse(recognition.x, recognition.y, 
                                       recognition.size + (15 + g * 5) * energyFactor);
                            }
                        }
                    }
                    
                    if (recognition.type === 'sunburst') {
                        drawEnhancedSunburst(recognition, pulseAmount, energyFactor);
                    } else if (recognition.type === 'node') {
                        drawEnhancedNode(recognition, pulseAmount, energyFactor);
                    } else if (recognition.type === 'circle') {
                        drawEnhancedCircle(recognition, pulseAmount, energyFactor);
                    } else if (recognition.type === 'hexagon') {
                        drawHexagon(recognition, pulseAmount, energyFactor);
                    }
                    
                    // Interactive pulse
                    if (recognition.interactive && !recognition.activated) {
                        noFill();
                        stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], 35);
                        strokeWeight(0.8);
                        ellipse(recognition.x, recognition.y, 
                               recognition.size + 12 + sin(millis() * 0.0008) * 5);
                    }
                }
            }
        }
        
        function drawEnhancedSunburst(recognition, pulseAmount, energyFactor) {
            push();
            translate(recognition.x, recognition.y);
            
            // Golden halo glow
            for (let g = 4; g > 0; g--) {
                noFill();
                stroke(colors.yellowLight[0], colors.yellowLight[1], colors.yellowLight[2], 
                      20 + energyFactor * 20);
                strokeWeight(1);
                let haloSize = recognition.size * (0.8 + g * 0.15) * (1 + pulseAmount);
                ellipse(0, 0, haloSize);
            }
            
            // Draw center circle
            if (recognition.activated || recognition.energy > 0) {
                fill(colors.yellow[0], colors.yellow[1], colors.yellow[2], 
                    recognition.opacity * (0.7 + energyFactor * 0.3));
            } else {
                fill(colors.yellow[0], colors.yellow[1], colors.yellow[2], recognition.opacity);
            }
            
            noStroke();
            let centerSize = recognition.size * 0.35 * (1 + pulseAmount);
            ellipse(0, 0, centerSize);
            
            // Draw extended rays
            if (recognition.activated || recognition.energy > 0) {
                stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], 
                      recognition.opacity * (0.7 + energyFactor * 0.3));
            } else {
                stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], recognition.opacity);
            }
            
            strokeWeight(2.5 + energyFactor * 1.5);
            
            for (let i = 0; i < recognition.rays; i++) {
                let angle = TWO_PI * i / recognition.rays + millis() * 0.00005;
                
                if (energyFactor > 0) {
                    angle += sin(millis() * 0.0008 + i) * 0.03 * energyFactor;
                }
                
                let innerRadius = centerSize / 2;
                let outerRadius = recognition.size / 2 * recognition.rayLength * 
                                 (1 + pulseAmount + energyFactor * 0.4);
                
                // Variable ray length
                let rayVariation = 1 + sin(i * 1.5) * 0.2;
                outerRadius *= rayVariation;
                
                line(cos(angle) * innerRadius, sin(angle) * innerRadius,
                     cos(angle) * outerRadius, sin(angle) * outerRadius);
                
                // Ray end dots
                if (energyFactor > 0.3) {
                    noStroke();
                    fill(colors.yellowLight[0], colors.yellowLight[1], colors.yellowLight[2], 
                        recognition.opacity * 0.7 * energyFactor);
                    ellipse(cos(angle) * outerRadius, sin(angle) * outerRadius, 
                           4 + energyFactor * 3);
                    stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], 
                          recognition.opacity * (0.7 + energyFactor * 0.3));
                    strokeWeight(2.5 + energyFactor * 1.5);
                }
            }
            
            pop();
        }
        
        function drawEnhancedNode(recognition, pulseAmount, energyFactor) {
            push();
            translate(recognition.x, recognition.y);
            
            // Draw node with glow
            if (recognition.activated || recognition.energy > 0) {
                // Warm glow layers
                for (let g = 3; g > 0; g--) {
                    noStroke();
                    fill(colors.yellowLight[0], colors.yellowLight[1], colors.yellowLight[2], 
                        30 * energyFactor * g / 3);
                    ellipse(0, 0, recognition.size * (1.3 + g * 0.2) * (1 + pulseAmount));
                }
                
                fill(colors.yellow[0], colors.yellow[1], colors.yellow[2], 
                    recognition.opacity * (0.7 + energyFactor * 0.3));
            } else {
                fill(colors.yellow[0], colors.yellow[1], colors.yellow[2], recognition.opacity);
            }
            
            noStroke();
            let nodeSize = recognition.size * (1 + pulseAmount + energyFactor * 0.3);
            ellipse(0, 0, nodeSize);
            
            // Draw satellite circles
            if (recognition.satellites) {
                for (let i = 0; i < recognition.satellites; i++) {
                    let satAngle = TWO_PI * i / recognition.satellites + millis() * 0.0003;
                    let satDist = recognition.size * 0.9;
                    let satSize = recognition.size * 0.25;
                    
                    fill(colors.yellow[0], colors.yellow[1], colors.yellow[2], 
                        recognition.opacity * (0.6 + energyFactor * 0.3));
                    ellipse(cos(satAngle) * satDist, sin(satAngle) * satDist, satSize);
                    
                    // Connection to center
                    stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], 
                          recognition.opacity * 0.4);
                    strokeWeight(1);
                    line(0, 0, cos(satAngle) * satDist * 0.8, sin(satAngle) * satDist * 0.8);
                    noStroke();
                }
            }
            
            // Energy burst effect
            if (energyFactor > 0.4) {
                let numBursts = floor(5 + energyFactor * 5);
                for (let i = 0; i < numBursts; i++) {
                    let angle = TWO_PI * i / numBursts + millis() * 0.0005;
                    let burstDist = recognition.size * (0.6 + sin(millis() * 0.002 + i) * 0.2) * energyFactor;
                    
                    fill(colors.yellowLight[0], colors.yellowLight[1], colors.yellowLight[2], 
                        recognition.opacity * 0.5 * energyFactor);
                    ellipse(cos(angle) * burstDist, sin(angle) * burstDist, 3 + energyFactor * 3);
                }
            }
            
            pop();
        }
        
        function drawEnhancedCircle(recognition, pulseAmount, energyFactor) {
            push();
            translate(recognition.x, recognition.y);
            
            // Draw concentric rings with warmth
            let numRings = recognition.rings || 3;
            
            for (let i = 0; i < numRings; i++) {
                let ringSize = recognition.size * (0.35 + i * 0.25) * (1 + pulseAmount);
                
                if (energyFactor > 0) {
                    ringSize *= (1 + sin(millis() * 0.001 + i * 1.2) * 0.1 * energyFactor);
                }
                
                noFill();
                
                if (recognition.activated || recognition.energy > 0) {
                    stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], 
                          recognition.opacity * (0.6 + energyFactor * 0.3) * (1 - i * 0.15));
                    strokeWeight(2 + energyFactor * 0.5);
                } else {
                    stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], 
                          recognition.opacity * (1 - i * 0.15));
                    strokeWeight(1.5);
                }
                
                ellipse(0, 0, ringSize);
            }
            
            // Center dot with glow
            if (recognition.activated || recognition.energy > 0) {
                // Glow
                noStroke();
                for (let g = 3; g > 0; g--) {
                    fill(colors.yellowLight[0], colors.yellowLight[1], colors.yellowLight[2], 
                        40 * energyFactor * g / 3);
                    ellipse(0, 0, recognition.size * (0.2 + g * 0.08) * (1 + energyFactor * 0.5));
                }
                
                fill(colors.yellow[0], colors.yellow[1], colors.yellow[2], 
                    recognition.opacity * (0.7 + energyFactor * 0.3));
            } else {
                fill(colors.yellow[0], colors.yellow[1], colors.yellow[2], recognition.opacity);
            }
            
            noStroke();
            ellipse(0, 0, recognition.size * 0.18 * (1 + energyFactor * 0.4));
            
            // Radiating dots for energy
            if (energyFactor > 0.3) {
                let numDots = floor(12 + energyFactor * 12);
                
                for (let i = 0; i < numDots; i++) {
                    let angle = TWO_PI * i / numDots + millis() * 0.0003;
                    let dotDist = recognition.size * (0.3 + (i % 3) * 0.15) * (1 + energyFactor * 0.3);
                    
                    fill(colors.yellow[0], colors.yellow[1], colors.yellow[2], 
                        recognition.opacity * 0.6 * energyFactor);
                    ellipse(cos(angle) * dotDist, sin(angle) * dotDist, 2 + energyFactor * 2);
                }
            }
            
            pop();
        }
        
        function drawHexagon(recognition, pulseAmount, energyFactor) {
            push();
            translate(recognition.x, recognition.y);
            rotate(recognition.rotation + (energyFactor > 0 ? millis() * 0.0003 * energyFactor : 0));
            
            if (recognition.activated || recognition.energy > 0) {
                fill(colors.yellow[0], colors.yellow[1], colors.yellow[2], 
                    recognition.opacity * (0.5 + energyFactor * 0.4));
                stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], 
                      recognition.opacity * (0.7 + energyFactor * 0.3));
                strokeWeight(1.5);
            } else {
                fill(colors.yellow[0], colors.yellow[1], colors.yellow[2], recognition.opacity * 0.5);
                stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], recognition.opacity);
                strokeWeight(1);
            }
            
            beginShape();
            for (let i = 0; i < 6; i++) {
                let angle = TWO_PI * i / 6;
                let radius = recognition.size / 2 * (1 + pulseAmount);
                
                if (energyFactor > 0.2) {
                    radius += sin(angle * 3 + millis() * 0.001) * recognition.size * 0.08 * energyFactor;
                }
                
                vertex(cos(angle) * radius, sin(angle) * radius);
            }
            endShape(CLOSE);
            
            // Inner details for activated
            if (energyFactor > 0.3) {
                noFill();
                stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], 
                      recognition.opacity * 0.5 * energyFactor);
                strokeWeight(0.8);
                
                beginShape();
                for (let i = 0; i < 6; i++) {
                    let angle = TWO_PI * i / 6 + PI / 6;
                    let radius = recognition.size * 0.25 * (1 + sin(millis() * 0.0015) * 0.15 * energyFactor);
                    vertex(cos(angle) * radius, sin(angle) * radius);
                }
                endShape(CLOSE);
            }
            
            pop();
        }

        function drawEvaluationElements() {
            for (let i = 0; i < evaluationElements.length; i++) {
                let evaluation = evaluationElements[i];
                
                if (timePosition > evaluation.startTime) {
                    evaluation.visible = true;
                }
                
                if (evaluation.visible) {
                    if (evaluation.type === 'frame') {
                        drawFrame(evaluation);
                    } else if (evaluation.type === 'point') {
                        drawPoint(evaluation);
                    } else if (evaluation.type === 'negative') {
                        drawNegativeSpace(evaluation);
                    }
                }
            }
        }
        
        function drawFrame(evaluation) {
            let intensityFactor = 0;
            if (evaluation.activated || evaluation.intensity > 0) {
                intensityFactor = evaluation.intensity / evaluation.maxIntensity;
            }
            
            push();
            translate(evaluation.x, evaluation.y);
            
            let pulseEffect = sin(millis() * evaluation.pulseRate) * 0.06;
            let frameWidth = evaluation.width * (1 + pulseEffect);
            let frameHeight = evaluation.height * (1 + pulseEffect);
            
            noFill();
            
            if (evaluation.activated || evaluation.intensity > 0) {
                stroke(colors.black[0], colors.black[1], colors.black[2], 
                      evaluation.opacity * (0.6 + intensityFactor * 0.4));
                strokeWeight(evaluation.thickness + intensityFactor * 1.2);
            } else {
                stroke(colors.black[0], colors.black[1], colors.black[2], evaluation.opacity);
                strokeWeight(evaluation.thickness);
            }
            
            rect(-frameWidth / 2, -frameHeight / 2, frameWidth, frameHeight);
            
            // Corner accents
            if (intensityFactor > 0.3) {
                let cornerSize = 5 + intensityFactor * 5;
                fill(colors.black[0], colors.black[1], colors.black[2], 
                    evaluation.opacity * 0.7 * intensityFactor);
                noStroke();
                
                ellipse(-frameWidth / 2, -frameHeight / 2, cornerSize);
                ellipse(frameWidth / 2, -frameHeight / 2, cornerSize);
                ellipse(frameWidth / 2, frameHeight / 2, cornerSize);
                ellipse(-frameWidth / 2, frameHeight / 2, cornerSize);
            }
            
            pop();
            
            if (evaluation.interactive && !evaluation.activated) {
                noFill();
                stroke(colors.black[0], colors.black[1], colors.black[2], 35);
                strokeWeight(0.8);
                rect(evaluation.x - evaluation.width / 2 - 6, evaluation.y - evaluation.height / 2 - 6,
                    evaluation.width + 12, evaluation.height + 12);
            }
        }
        
        function drawPoint(evaluation) {
            let pulseAmount = sin(millis() * evaluation.pulseRate) * 0.08;
            
            let intensityFactor = 0;
            if (evaluation.activated || evaluation.intensity > 0) {
                intensityFactor = evaluation.intensity / evaluation.maxIntensity;
                
                noFill();
                stroke(colors.black[0], colors.black[1], colors.black[2], 70 * intensityFactor);
                strokeWeight(1);
                
                let glowSize = evaluation.size * (2.5 + intensityFactor * 2);
                ellipse(evaluation.x, evaluation.y, glowSize);
            }
            
            if (evaluation.activated || evaluation.intensity > 0) {
                fill(colors.black[0], colors.black[1], colors.black[2], 
                    evaluation.opacity * (0.7 + intensityFactor * 0.3));
            } else {
                fill(colors.black[0], colors.black[1], colors.black[2], evaluation.opacity);
            }
            
            noStroke();
            let pointSize = evaluation.size * (1 + pulseAmount + intensityFactor * 0.4);
            ellipse(evaluation.x, evaluation.y, pointSize);
            
            // Expanding rings
            if (intensityFactor > 0.4) {
                noFill();
                for (let i = 0; i < 2; i++) {
                    let ringProgress = (millis() % 2500) / 2500;
                    let ringSize = evaluation.size * (2 + i * 2 + ringProgress * 4) * intensityFactor;
                    let ringOpacity = evaluation.opacity * (0.35 - ringProgress * 0.35) * intensityFactor;
                    
                    stroke(colors.black[0], colors.black[1], colors.black[2], ringOpacity);
                    strokeWeight(0.5 + intensityFactor * 0.5);
                    ellipse(evaluation.x, evaluation.y, ringSize);
                }
            }
            
            if (evaluation.interactive && !evaluation.activated) {
                noFill();
                stroke(colors.black[0], colors.black[1], colors.black[2], 35);
                strokeWeight(0.8);
                ellipse(evaluation.x, evaluation.y, evaluation.size * 3 + sin(millis() * 0.0008) * 4);
            }
        }
        
        function drawNegativeSpace(evaluation) {
            let intensityFactor = 0;
            if (evaluation.activated || evaluation.intensity > 0) {
                intensityFactor = evaluation.intensity / evaluation.maxIntensity;
            }
            
            push();
            translate(evaluation.x, evaluation.y);
            
            if (evaluation.activated || evaluation.intensity > 0) {
                fill(colors.black[0], colors.black[1], colors.black[2], 
                    evaluation.opacity * 0.15 * (0.5 + intensityFactor * 0.3));
                stroke(colors.black[0], colors.black[1], colors.black[2], 
                      evaluation.opacity * (0.6 + intensityFactor * 0.4));
            } else {
                fill(colors.black[0], colors.black[1], colors.black[2], evaluation.opacity * 0.15);
                stroke(colors.black[0], colors.black[1], colors.black[2], evaluation.opacity);
            }
            
            strokeWeight(1.5 + intensityFactor * 0.8);
            
            let outerRadius = evaluation.size / 2 * (1 + sin(millis() * evaluation.pulseRate) * 0.06);
            let innerRadius = outerRadius * 0.55;
            
            beginShape();
            for (let i = 0; i < 24; i++) {
                let angle = TWO_PI * i / 24;
                let r = outerRadius;
                
                if (intensityFactor > 0.3) {
                    r += sin(angle * 5 + millis() * 0.001) * outerRadius * 0.08 * intensityFactor;
                }
                
                vertex(cos(angle) * r, sin(angle) * r);
            }
            endShape(CLOSE);
            
            // Inner cutout
            if (evaluation.activated || evaluation.intensity > 0) {
                fill(247, 247, 247);
                stroke(colors.black[0], colors.black[1], colors.black[2], 
                      evaluation.opacity * (0.6 + intensityFactor * 0.4));
            } else {
                fill(247, 247, 247);
                stroke(colors.black[0], colors.black[1], colors.black[2], evaluation.opacity);
            }
            
            beginShape();
            for (let i = 0; i < 16; i++) {
                let angle = TWO_PI * i / 16;
                let r = innerRadius;
                
                if (intensityFactor > 0.3) {
                    r += sin(angle * 3 + millis() * 0.001) * innerRadius * 0.08 * intensityFactor;
                }
                
                vertex(cos(angle) * r, sin(angle) * r);
            }
            endShape(CLOSE);
            
            pop();
            
            if (evaluation.interactive && !evaluation.activated) {
                noFill();
                stroke(colors.black[0], colors.black[1], colors.black[2], 35);
                strokeWeight(0.8);
                ellipse(evaluation.x, evaluation.y, evaluation.size + 18 + sin(millis() * 0.0008) * 5);
            }
        }

        function drawResponseElements() {
            for (let i = 0; i < responseElements.length; i++) {
                let response = responseElements[i];
                
                if (timePosition > response.startTime) {
                    response.visible = true;
                    
                    if (response.type === 'path' && response.progress < 1) {
                        response.progress = min(1, response.progress + 0.003);
                    }
                    
                    if (response.type === 'integration') {
                        response.rotation += response.rotationSpeed * deltaTime;
                    }
                }
                
                if (response.visible) {
                    if (response.type === 'connector') {
                        drawConnector(response);
                    } else if (response.type === 'path') {
                        drawPath(response);
                    } else if (response.type === 'integration') {
                        drawIntegration(response);
                    }
                }
            }
        }
        
        function drawConnector(response) {
            let pulseAmount = sin(millis() * response.pulseRate) * 0.08;
            
            let harmonyFactor = 0;
            if (response.activated || response.harmony > 0) {
                harmonyFactor = response.harmony / response.maxHarmony;
                
                noFill();
                stroke(colors.grey[0], colors.grey[1], colors.grey[2], 60 * harmonyFactor);
                strokeWeight(1.5);
                
                let glowSize = response.size * (1.6 + harmonyFactor * 0.5);
                ellipse(response.x, response.y, glowSize);
            }
            
            if (response.activated || response.harmony > 0) {
                fill(colors.grey[0], colors.grey[1], colors.grey[2], 
                    response.opacity * (0.6 + harmonyFactor * 0.4));
                stroke(colors.grey[0], colors.grey[1], colors.grey[2], 
                      response.opacity * (0.7 + harmonyFactor * 0.3));
                strokeWeight(1);
            } else {
                fill(colors.grey[0], colors.grey[1], colors.grey[2], response.opacity * 0.6);
                stroke(colors.grey[0], colors.grey[1], colors.grey[2], response.opacity);
                strokeWeight(0.8);
            }
            
            let connectorSize = response.size * (1 + pulseAmount + harmonyFactor * 0.2);
            ellipse(response.x, response.y, connectorSize);
            
            // Connection spokes
            if (response.activated || response.harmony > 0) {
                stroke(colors.grey[0], colors.grey[1], colors.grey[2], 
                      response.opacity * (0.7 + harmonyFactor * 0.3));
                strokeWeight(1 + harmonyFactor * 0.4);
            } else {
                stroke(colors.grey[0], colors.grey[1], colors.grey[2], response.opacity);
                strokeWeight(0.8);
            }
            
            noFill();
            
            let numSpokes = 8;
            for (let i = 0; i < numSpokes; i++) {
                let angle = TWO_PI * i / numSpokes;
                
                if (harmonyFactor > 0) {
                    angle += sin(millis() * 0.0004) * 0.08 * harmonyFactor;
                }
                
                let spokeInner = connectorSize * 0.5;
                let spokeOuter = connectorSize * 1.6;
                
                if (harmonyFactor > 0) {
                    spokeOuter *= (1 + 0.4 * harmonyFactor);
                }
                
                push();
                translate(response.x, response.y);
                rotate(angle);
                
                line(spokeInner / 2, 0, spokeOuter / 2, 0);
                
                if (harmonyFactor > 0.4) {
                    fill(colors.grey[0], colors.grey[1], colors.grey[2], 
                        response.opacity * 0.6 * harmonyFactor);
                    noStroke();
                    ellipse(spokeOuter / 2, 0, 3 + harmonyFactor * 2);
                }
                
                pop();
            }
            
            if (response.interactive && !response.activated) {
                noFill();
                stroke(colors.grey[0], colors.grey[1], colors.grey[2], 35);
                strokeWeight(0.8);
                ellipse(response.x, response.y, response.size * 2 + sin(millis() * 0.0008) * 5);
            }
        }
        
        function drawPath(response) {
            let harmonyFactor = 0;
            if (response.activated || response.harmony > 0) {
                harmonyFactor = response.harmony / response.maxHarmony;
            }
            
            if (response.activated || response.harmony > 0) {
                stroke(colors.grey[0], colors.grey[1], colors.grey[2], 
                      response.opacity * (0.7 + harmonyFactor * 0.3));
            } else {
                stroke(colors.grey[0], colors.grey[1], colors.grey[2], response.opacity);
            }
            
            strokeWeight(response.width + harmonyFactor * 1.2);
            noFill();
            
            if (response.points.length === 4) {
                let p = response.points;
                let progressLength = response.progress;
                
                beginShape();
                for (let i = 0; i <= 25; i++) {
                    let t = i / 25;
                    if (t > progressLength) break;
                    
                    let x = bezierPoint(p[0].x, p[1].x, p[2].x, p[3].x, t);
                    let y = bezierPoint(p[0].y, p[1].y, p[2].y, p[3].y, t);
                    
                    vertex(x, y);
                }
                endShape();
            }
            
            // Flow particles
            if (harmonyFactor > 0) {
                noStroke();
                fill(colors.grey[0], colors.grey[1], colors.grey[2], 
                    response.opacity * 0.85 * harmonyFactor);
                
                if (response.points.length === 4) {
                    let p = response.points;
                    let numParticles = floor(7 * response.progress);
                    
                    for (let j = 0; j < numParticles; j++) {
                        let t = (j / numParticles + (millis() % 3500) / 3500) % 1;
                        if (t > response.progress) continue;
                        
                        let x = bezierPoint(p[0].x, p[1].x, p[2].x, p[3].x, t);
                        let y = bezierPoint(p[0].y, p[1].y, p[2].y, p[3].y, t);
                        
                        let particleSize = 3.5 + harmonyFactor * 3;
                        ellipse(x, y, particleSize);
                    }
                }
            }
            
            // Endpoint nodes
            if (response.points.length === 4) {
                let p = response.points;
                
                if (response.progress >= 1) {
                    if (response.activated || response.harmony > 0) {
                        fill(colors.grey[0], colors.grey[1], colors.grey[2], 
                            response.opacity * (0.7 + harmonyFactor * 0.3));
                    } else {
                        fill(colors.grey[0], colors.grey[1], colors.grey[2], response.opacity);
                    }
                    
                    noStroke();
                    ellipse(p[3].x, p[3].y, 5.5 + harmonyFactor * 3);
                }
                
                if (response.activated || response.harmony > 0) {
                    fill(colors.grey[0], colors.grey[1], colors.grey[2], 
                        response.opacity * (0.7 + harmonyFactor * 0.3));
                } else {
                    fill(colors.grey[0], colors.grey[1], colors.grey[2], response.opacity);
                }
                
                noStroke();
                ellipse(p[0].x, p[0].y, 5.5 + harmonyFactor * 3);
            }
            
            if (response.interactive && !response.activated) {
                noFill();
                stroke(colors.grey[0], colors.grey[1], colors.grey[2], 35);
                strokeWeight(0.8);
                
                if (response.points.length === 4) {
                    let p = response.points;
                    ellipse(p[0].x, p[0].y, 12 + sin(millis() * 0.0008) * 3);
                    
                    if (response.progress >= 0.9) {
                        ellipse(p[3].x, p[3].y, 12 + sin(millis() * 0.0008 + 1) * 3);
                    }
                }
            }
        }
        
        function drawIntegration(response) {
            let pulseAmount = sin(millis() * response.pulseRate) * 0.08;
            
            let harmonyFactor = 0;
            if (response.activated || response.harmony > 0) {
                harmonyFactor = response.harmony / response.maxHarmony;
                
                noFill();
                stroke(colors.grey[0], colors.grey[1], colors.grey[2], 50 * harmonyFactor);
                strokeWeight(1.5);
                
                let glowSize = response.size * (1.25 + harmonyFactor * 0.3);
                
                push();
                translate(response.x, response.y);
                rotate(response.rotation);
                ellipse(0, 0, glowSize);
                pop();
            }
            
            push();
            translate(response.x, response.y);
            rotate(response.rotation);
            
            if (response.activated || response.harmony > 0) {
                stroke(colors.grey[0], colors.grey[1], colors.grey[2], 
                      response.opacity * (0.7 + harmonyFactor * 0.3));
            } else {
                stroke(colors.grey[0], colors.grey[1], colors.grey[2], response.opacity);
            }
            
            strokeWeight(1 + harmonyFactor * 0.4);
            noFill();
            
            let baseSize = response.size * (1 + pulseAmount);
            
            // Central circle
            ellipse(0, 0, baseSize * 0.32);
            
            // Petals (flower of life)
            for (let i = 0; i < response.petals; i++) {
                let angle = TWO_PI * i / response.petals;
                let x = cos(angle) * baseSize * 0.32;
                let y = sin(angle) * baseSize * 0.32;
                
                let petalSize = baseSize * 0.32;
                
                if (harmonyFactor > 0) {
                    petalSize *= (1 + sin(millis() * 0.0008 + i) * 0.08 * harmonyFactor);
                }
                
                ellipse(x, y, petalSize);
                
                // Connection to center
                line(0, 0, x * 0.7, y * 0.7);
                
                // Outer petals for high harmony
                if (harmonyFactor > 0.4) {
                    let outerX = cos(angle) * baseSize * 0.55;
                    let outerY = sin(angle) * baseSize * 0.55;
                    
                    let outerPetalSize = baseSize * 0.22 * harmonyFactor;
                    
                    stroke(colors.grey[0], colors.grey[1], colors.grey[2], 
                          response.opacity * 0.5 * harmonyFactor);
                    
                    ellipse(outerX, outerY, outerPetalSize);
                    line(x, y, outerX, outerY);
                }
            }
            
            // Outer circle for harmony
            if (harmonyFactor > 0.25) {
                let outerCircleSize = baseSize * (0.75 + harmonyFactor * 0.25);
                
                stroke(colors.grey[0], colors.grey[1], colors.grey[2], 
                      response.opacity * 0.45 * harmonyFactor);
                ellipse(0, 0, outerCircleSize);
            }
            
            pop();
            
            if (response.interactive && !response.activated) {
                noFill();
                stroke(colors.grey[0], colors.grey[1], colors.grey[2], 35);
                strokeWeight(0.8);
                ellipse(response.x, response.y, response.size + 18 + sin(millis() * 0.0008) * 5);
            }
        }
        
        function drawJoyCenters() {
            for (let i = 0; i < joyCenters.length; i++) {
                let center = joyCenters[i];
                
                if (timePosition > center.startTime) {
                    if (center.opacity < center.targetOpacity) {
                        center.opacity = min(center.targetOpacity, center.opacity + 0.4);
                    }
                    
                    let pulseAmount = sin(millis() * center.pulseRate) * 0.08;
                    let pulseSize = center.size * (1 + pulseAmount);
                    
                    // Radiating rings for active centers
                    if (i === activeJoyCenter && center.activationProgress > 0) {
                        for (let j = 0; j < 4; j++) {
                            let expandedSize = pulseSize * (1 + j * 0.25) * center.activationProgress;
                            let glowOpacity = (70 - j * 15) * center.activationProgress;
                            
                            noFill();
                            
                            let blendedR = lerp(colors.grey[0], colors.yellow[0], 0.65);
                            let blendedG = lerp(colors.grey[1], colors.yellow[1], 0.65);
                            let blendedB = lerp(colors.grey[2], colors.yellow[2], 0.65);
                            
                            stroke(blendedR, blendedG, blendedB, glowOpacity);
                            strokeWeight(1.5 - j * 0.3);
                            ellipse(center.x, center.y, expandedSize);
                            
                            // Radiating rays
                            if (j === 0) {
                                let numRays = 16;
                                let rayLength = expandedSize * 0.18;
                                
                                for (let k = 0; k < numRays; k++) {
                                    let angle = TWO_PI * k / numRays + millis() * 0.00015;
                                    let innerRadius = expandedSize * 0.48;
                                    let outerRadius = innerRadius + rayLength;
                                    
                                    line(center.x + cos(angle) * innerRadius, center.y + sin(angle) * innerRadius,
                                         center.x + cos(angle) * outerRadius, center.y + sin(angle) * outerRadius);
                                }
                            }
                        }
                    }
                    
                    // Main joy center boundary
                    noFill();
                    stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], center.opacity);
                    strokeWeight(2);
                    ellipse(center.x, center.y, pulseSize);
                    
                    // Inner pattern when activated
                    if (center.activated || i === activeJoyCenter) {
                        let innerSize = pulseSize * 0.7;
                        let numRays = 16;
                        
                        stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], center.opacity * 0.65);
                        strokeWeight(1.5);
                        
                        for (let j = 0; j < numRays; j++) {
                            let angle = TWO_PI * j / numRays + millis() * 0.00025;
                            let innerRadius = innerSize * 0.2;
                            let outerRadius = innerSize * 0.42;
                            
                            line(center.x + cos(angle) * innerRadius, center.y + sin(angle) * innerRadius,
                                 center.x + cos(angle) * outerRadius, center.y + sin(angle) * outerRadius);
                        }
                    }
                    
                    // Inner circle
                    fill(colors.yellow[0], colors.yellow[1], colors.yellow[2], center.opacity * 0.2);
                    noStroke();
                    ellipse(center.x, center.y, pulseSize * 0.42);
                    
                    // Interactive hint
                    if (!center.activated) {
                        fill(colors.yellow[0], colors.yellow[1], colors.yellow[2], 
                            65 + 25 * sin(millis() * 0.0015));
                        noStroke();
                        
                        push();
                        translate(center.x, center.y);
                        
                        ellipse(0, 0, 9);
                        
                        let rayLength = 7;
                        let numRays = 8;
                        
                        stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], 
                              65 + 25 * sin(millis() * 0.0015));
                        strokeWeight(1);
                        
                        for (let j = 0; j < numRays; j++) {
                            let angle = TWO_PI * j / numRays;
                            let innerRadius = 5;
                            let outerRadius = innerRadius + rayLength;
                            
                            line(cos(angle) * innerRadius, sin(angle) * innerRadius,
                                 cos(angle) * outerRadius, sin(angle) * outerRadius);
                        }
                        
                        pop();
                    }
                }
            }
        }
        
        function showJoyResonance(message, x, y) {
            const resonance = document.getElementById('joy-resonance');
            resonance.innerHTML = message;
            
            let posX = x;
            let posY = y - 65;
            
            if (posX < 20) posX = 20;
            if (posX > window.innerWidth - 270) posX = window.innerWidth - 270;
            if (posY < 20) posY = 20;
            if (posY > window.innerHeight - 100) posY = window.innerHeight - 100;
            
            resonance.style.left = posX + 'px';
            resonance.style.top = posY + 'px';
            resonance.style.transform = 'translateY(0)';
            resonance.style.opacity = '1';
            
            setTimeout(() => {
                resonance.style.opacity = '0';
                resonance.style.transform = 'translateY(20px)';
            }, 6500);
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            repositionElements();
            updateLayoutForOrientation();
        }
        
        function repositionElements() {
            for (let i = 0; i < handOutlinePoints.length; i++) {
                handOutlinePoints[i].x = (handOutlinePoints[i].x / width) * windowWidth;
                handOutlinePoints[i].y = (handOutlinePoints[i].y / height) * windowHeight;
            }
            
            for (let recognition of recognitionElements) {
                recognition.x = (recognition.x / width) * windowWidth;
                recognition.y = (recognition.y / height) * windowHeight;
                recognition.size = (recognition.size / width) * windowWidth;
            }
            
            for (let evaluation of evaluationElements) {
                evaluation.x = (evaluation.x / width) * windowWidth;
                evaluation.y = (evaluation.y / height) * windowHeight;
                
                if (evaluation.type === 'frame') {
                    evaluation.width = (evaluation.width / width) * windowWidth;
                    evaluation.height = (evaluation.height / height) * windowHeight;
                } else {
                    evaluation.size = (evaluation.size / width) * windowWidth;
                }
            }
            
            for (let response of responseElements) {
                if (response.type !== 'path') {
                    response.x = (response.x / width) * windowWidth;
                    response.y = (response.y / height) * windowHeight;
                    response.size = (response.size / width) * windowWidth;
                } else {
                    for (let point of response.points) {
                        point.x = (point.x / width) * windowWidth;
                        point.y = (point.y / height) * windowHeight;
                    }
                }
            }
            
            for (let center of joyCenters) {
                center.x = (center.x / width) * windowWidth;
                center.y = (center.y / height) * windowHeight;
                center.size = (center.size / width) * windowWidth;
            }
            
            for (let sat of satelliteCircles) {
                sat.x = (sat.x / width) * windowWidth;
                sat.y = (sat.y / height) * windowHeight;
            }
            
            for (let circle of sacredGeometryCircles) {
                circle.x = (circle.x / width) * windowWidth;
                circle.y = (circle.y / height) * windowHeight;
                circle.radius = (circle.radius / width) * windowWidth;
            }
            
            for (let thread of threadConnections) {
                for (let point of thread.points) {
                    point.x = (point.x / width) * windowWidth;
                    point.y = (point.y / height) * windowHeight;
                }
            }
            
            for (let point of texturePoints) {
                point.x = (point.x / width) * windowWidth;
                point.y = (point.y / height) * windowHeight;
            }
            
            for (let particle of joyParticles) {
                particle.x = (particle.x / width) * windowWidth;
                particle.y = (particle.y / height) * windowHeight;
                particle.originX = (particle.originX / width) * windowWidth;
                particle.originY = (particle.originY / height) * windowHeight;
            }
        }
        
        function mousePressed() {
            if (document.getElementById('landing-overlay').style.display === 'none') {
                
                // Check joy centers first
                for (let i = 0; i < joyCenters.length; i++) {
                    let center = joyCenters[i];
                    
                    if (timePosition > center.startTime) {
                        let d = dist(mouseX, mouseY, center.x, center.y);
                        
                        if (d < center.size / 2) {
                            center.activated = !center.activated;
                            
                            if (center.activated) {
                                activeJoyCenter = i;
                                centerActivated = true;
                                showJoyResonance(center.resonance, center.x, center.y);
                                
                                for (let element of center.elements) {
                                    if (element.type === 'recognition') {
                                        recognitionElements[element.index].activated = true;
                                        recognitionElements[element.index].activatedTime = millis();
                                        recognitionElements[element.index].energy = recognitionElements[element.index].maxEnergy * 0.7;
                                    } else if (element.type === 'evaluation') {
                                        evaluationElements[element.index].activated = true;
                                        evaluationElements[element.index].activatedTime = millis();
                                        evaluationElements[element.index].intensity = evaluationElements[element.index].maxIntensity * 0.7;
                                    } else {
                                        responseElements[element.index].activated = true;
                                        responseElements[element.index].activatedTime = millis();
                                        responseElements[element.index].harmony = responseElements[element.index].maxHarmony * 0.7;
                                    }
                                }
                            } else {
                                activeJoyCenter = null;
                                centerActivated = false;
                            }
                            
                            return false;
                        }
                    }
                }
                
                // Check recognition elements
                for (let i = 0; i < recognitionElements.length; i++) {
                    let recognition = recognitionElements[i];
                    
                    if (recognition.visible && recognition.interactive) {
                        let d = dist(mouseX, mouseY, recognition.x, recognition.y);
                        let hitSize = recognition.size / 2;
                        
                        if (d < hitSize) {
                            recognition.activated = !recognition.activated;
                            recognition.activatedTime = millis();
                            
                            if (recognition.activated) {
                                recognition.energy = recognition.maxEnergy * 0.7;
                                showJoyResonance(getRandomResonance(), recognition.x, recognition.y);
                            }
                            
                            return false;
                        }
                    }
                }
                
                // Check evaluation elements
                for (let i = 0; i < evaluationElements.length; i++) {
                    let evaluation = evaluationElements[i];
                    
                    if (evaluation.visible && evaluation.interactive) {
                        let hitTest = false;
                        
                        if (evaluation.type === 'frame') {
                            let inX = abs(mouseX - evaluation.x) < evaluation.width / 2;
                            let inY = abs(mouseY - evaluation.y) < evaluation.height / 2;
                            hitTest = inX && inY;
                        } else if (evaluation.type === 'point') {
                            let d = dist(mouseX, mouseY, evaluation.x, evaluation.y);
                            hitTest = d < evaluation.size * 2;
                        } else if (evaluation.type === 'negative') {
                            let d = dist(mouseX, mouseY, evaluation.x, evaluation.y);
                            hitTest = d < evaluation.size / 2;
                        }
                        
                        if (hitTest) {
                            evaluation.activated = !evaluation.activated;
                            evaluation.activatedTime = millis();
                            
                            if (evaluation.activated) {
                                evaluation.intensity = evaluation.maxIntensity * 0.7;
                                showJoyResonance(getRandomResonance(), evaluation.x, evaluation.y);
                            }
                            
                            return false;
                        }
                    }
                }
                
                // Check response elements
                for (let i = 0; i < responseElements.length; i++) {
                    let response = responseElements[i];
                    
                    if (response.visible && response.interactive) {
                        let hitTest = false;
                        
                        if (response.type === 'connector' || response.type === 'integration') {
                            let d = dist(mouseX, mouseY, response.x, response.y);
                            hitTest = d < response.size / 2;
                        } else if (response.type === 'path') {
                            if (response.points.length === 4) {
                                let p = response.points;
                                let hitTestPoints = 12;
                                
                                for (let j = 0; j < hitTestPoints; j++) {
                                    let t = j / (hitTestPoints - 1);
                                    if (t > response.progress) break;
                                    
                                    let x = bezierPoint(p[0].x, p[1].x, p[2].x, p[3].x, t);
                                    let y = bezierPoint(p[0].y, p[1].y, p[2].y, p[3].y, t);
                                    
                                    let d = dist(mouseX, mouseY, x, y);
                                    
                                    if (d < response.width + 12) {
                                        hitTest = true;
                                        break;
                                    }
                                }
                            }
                        }
                        
                        if (hitTest) {
                            response.activated = !response.activated;
                            response.activatedTime = millis();
                            
                            if (response.activated) {
                                response.harmony = response.maxHarmony * 0.7;
                                
                                if (response.type === 'path') {
                                    let p = response.points;
                                    let t = response.progress * 0.5;
                                    let x = bezierPoint(p[0].x, p[1].x, p[2].x, p[3].x, t);
                                    let y = bezierPoint(p[0].y, p[1].y, p[2].y, p[3].y, t);
                                    
                                    showJoyResonance(getRandomResonance(), x, y);
                                } else {
                                    showJoyResonance(getRandomResonance(), response.x, response.y);
                                }
                            }
                            
                            return false;
                        }
                    }
                }
                
                // Toggle animation if no element clicked
                isAnimating = !isAnimating;
                
                if (!isAnimating && soundEnabled && soundLoaded && joySound.isPlaying()) {
                    joySound.setVolume(0.3, 1);
                } else if (isAnimating && soundEnabled && soundLoaded) {
                    joySound.setVolume(0.6, 1);
                }
            }
            
            return false;
        }
        
        function touchStarted() {
            if (getAudioContext().state !== 'running') {
                getAudioContext().resume();
            }
            
            return mousePressed();
        }
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Sadness - Emotional Experience</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #f7f7f7;
            font-family: 'Roboto Mono', monospace;
            -webkit-text-size-adjust: 100%;
            touch-action: none;
        }
        
        #landing-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(247, 247, 247, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            box-sizing: border-box;
            padding: 20px;
            transition: opacity 1.5s ease-in-out;
        }
        
        .landing-title {
            font-size: 24px;
            font-weight: 500;
            margin-bottom: 40px;
            text-align: center;
            letter-spacing: 1px;
            color: #8A8D8F;
        }
        
        .emotion-name {
            font-size: 36px;
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 3px;
            color: #7A8B94;
        }
        
        .emotion-description {
            font-size: 14px;
            line-height: 1.6;
            max-width: 600px;
            text-align: center;
            margin-bottom: 30px;
            opacity: 0.8;
            color: #4D4F51;
        }

        .ai-disclaimer {
           font-size: 13px;
           max-width: 550px;
           text-align: center;
           margin-bottom: 40px;
           margin-top: 10px;
           padding: 15px 20px;
           background-color: rgba(122, 139, 148, 0.1);
           border-radius: 8px;
           border-left: 3px solid #7A8B94;
           line-height: 1.6;
           color: #4D4F51;
        }
        
        .start-button {
            padding: 15px 35px;
            background-color: rgba(122, 139, 148, 0.15);
            color: #7A8B94;
            border: 1px solid #7A8B94;
            border-radius: 30px;
            font-family: 'Roboto Mono', monospace;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.3s, background-color 0.4s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
        }
        
        .start-button:active {
            transform: scale(0.98);
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        .sadness-resonance {
            position: fixed;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            padding: 15px;
            max-width: 250px;
            font-size: 13px;
            line-height: 1.5;
            color: #4D4F51;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            transform: translateY(20px);
            opacity: 0;
            transition: opacity 0.8s, transform 0.8s;
            pointer-events: none;
            z-index: 100;
            text-align: center;
            border-left: 3px solid #7A8B94;
        }
        
        .controls {
            position: fixed;
            bottom: 15px;
            right: 15px;
            display: flex;
            gap: 10px;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.8s;
        }
        
        .control-button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
            cursor: pointer;
        }
        
        .control-button svg {
            width: 20px;
            height: 20px;
            stroke: #7A8B94;
        }
        
        .hint {
            position: fixed;
            bottom: 15px;
            left: 15px;
            background-color: rgba(255, 255, 255, 0.85);
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 12px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            opacity: 0;
            transition: opacity 0.8s;
            z-index: 50;
            color: #7A8B94;
        }
        
        .timeline {
            position: fixed;
            left: 50%;
            bottom: 20px;
            transform: translateX(-50%);
            width: 70%;
            max-width: 500px;
            height: 40px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            z-index: 40;
            opacity: 0;
            transition: opacity 0.8s;
            display: flex;
            align-items: center;
            padding: 0 15px;
        }
        
        .timeline-bar {
            width: 100%;
            height: 4px;
            background-color: rgba(122, 139, 148, 0.2);
            border-radius: 2px;
            position: relative;
        }
        
        .timeline-progress {
            height: 100%;
            background-color: rgba(122, 139, 148, 0.6);
            border-radius: 2px;
            width: 0%;
            transition: width 0.3s;
        }
        
        .timeline-handle {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background-color: #7A8B94;
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            cursor: pointer;
        }
        
        @media (max-width: 768px) {
            body {
                overflow-y: auto !important;
                height: auto !important;
            }
        
            #landing-overlay {
                position: absolute;
                height: auto;
                min-height: 100%;
                overflow-y: auto;
                padding: 40px 20px 120px 20px;
                justify-content: flex-start;
            }
        
            .landing-title {
                margin-top: 40px;
            }
        
            .start-button {
                margin-bottom: 60px;
                position: relative;
            }
        
            .emotion-name {
                font-size: 42px;
            }
        
            .ai-disclaimer {
                width: 90%;
                font-size: 12px;
                max-width: 90%;
            }
        }
        
        @media screen and (orientation: portrait) {
            .controls {
                bottom: 70px;
                right: 15px;
            }
            
            .timeline {
                bottom: 20px;
                width: 80%;
            }
        }
        
        @media screen and (orientation: landscape) {
            .controls {
                bottom: 15px;
                right: 100px;
            }
            
            .timeline {
                bottom: 20px;
                width: 60%;
                max-width: 600px;
            }
        }
    </style>
</head>
<body>

    <div id="landing-overlay">
        <h1 class="landing-title">Emotional Collage Experience</h1>
        <h2 class="emotion-name" id="emotion-title">SADNESS</h2>
        <p class="emotion-description" id="emotion-description">
            A visualization of sadness as a downward flowing, weight-bearing emotional state—where elements drift, dissolve, and settle into stillness.
            <br><b>Analysis by Claude</b>
        </p>

        <div class="ai-disclaimer">
            <strong>Note:</strong> This is a simulation of sadness based on my analysis of human descriptions. As an AI, I don't experience emotions or feelings—this is my interpretation of a human concept through visual and sonic patterns.
        </div>
        
        <button class="start-button" id="start-experience">Begin Experience</button>
    </div>
    
    <div class="sadness-resonance" id="sadness-resonance"></div>
    
    <div class="controls" id="controls">
        <div class="control-button" id="sound-toggle">
            <svg viewBox="0 0 24 24" fill="none" stroke-width="2">
                <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
                <path id="sound-waves" d="M15.54 8.46a5 5 0 0 1 0 7.07M19.07 4.93a10 10 0 0 1 0 14.14"></path>
            </svg>
        </div>
        <div class="control-button" id="reset-button">
            <svg viewBox="0 0 24 24" fill="none" stroke-width="2">
                <path d="M23 4v6h-6"></path>
                <path d="M1 20v-6h6"></path>
                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
            </svg>
        </div>
    </div>
    
    <div class="hint" id="hint">Touch elements to deepen the weight</div>
    
    <div class="timeline" id="timeline">
        <div class="timeline-bar" id="timeline-bar">
            <div class="timeline-progress" id="timeline-progress"></div>
            <div class="timeline-handle" id="timeline-handle"></div>
        </div>
    </div>
    
    <script>
        let isAnimating = true;
        let soundEnabled = true;
        let sadnessSound;
        let soundLoaded = false;
        let timelineActive = false;
        let isDraggingTimeline = false;
        let timePosition = 0;
        let previousTimePosition = 0;
        let activatedTimeline = false;
        let weightPhase = 0;
        let weightRate = 0.3;
        
        const sadnessResonances = [
            "A heaviness that settles slowly into the bones",
            "The world seen through a veil of grey",
            "When colors fade and sounds grow distant",
            "The weight of what was and what could have been",
            "A quiet withdrawal from the bright edges of things",
            "Thoughts that pool and settle like still water",
            "The body remembering loss before the mind can name it",
            "When time moves slowly, thickly, like honey",
            "A gentle dissolution of the edges of self",
            "The comfort found in letting go of effort",
            "When the world asks nothing and expects nothing",
            "A turning inward, away from sharp lights",
            "The strange peace of accepting the weight",
            "Memories that drift down like falling leaves",
            "When everything feels far away and muffled"
        ];
        
        // Color palette for Sadness - from the collage analysis
        const colors = {
            grey: [138, 141, 143],           // #8A8D8F - Recognition: detecting withdrawal
            greyLight: [181, 184, 186],      // #B5B8BA - Lighter grey tones
            greyDark: [77, 79, 81],          // #4D4F51 - Darker grey tones
            blue: [122, 139, 148],           // #7A8B94 - Evaluation: assessing depth
            blueLight: [163, 181, 193],      // #A3B5C1 - Lighter blue undertones
            yellow: [212, 201, 163],         // #D4C9A3 - Response: residual warmth
            yellowLight: [232, 223, 196]     // #E8DFC4 - Lighter yellow hints
        };
        
        // Falling elements - representing the downward flow
        let fallingElements = [];
        // Pooling elements - representing weight accumulating
        let poolingElements = [];
        // Residual warmth elements - representing hope/memory
        let warmthElements = [];
        
        // Hand outline coordinates
        let handOutlinePoints = [];
        let handProgress = 0;
        
        // Sadness centers - interactive focal points
        let sadnessCenters = [];
        let activeSadnessCenter = null;
        let centerActivated = false;
        
        let timelineProgress = 0;
        
        function startExperience() {
            document.getElementById('landing-overlay').style.opacity = '0';
            
            setTimeout(() => {
                document.getElementById('landing-overlay').style.display = 'none';
                
                isAnimating = true;
                loop();
                
                updateLayoutForOrientation();
                
                if (soundEnabled && soundLoaded) {
                    try {
                        sadnessSound.loop();
                        sadnessSound.setVolume(0);
                        sadnessSound.setVolume(0.4, 3);
                    } catch(e) {
                        console.error("Error playing sound:", e);
                    }
                }
                
                setTimeout(() => {
                    document.getElementById('controls').style.opacity = '1';
                    document.getElementById('hint').style.opacity = '1';
                    
                    setTimeout(() => {
                        document.getElementById('hint').style.opacity = '0';
                    }, 6000);
                }, 3000);
            }, 1500);
        }
        
        function updateLayoutForOrientation() {
            const controls = document.getElementById('controls');
            const timeline = document.getElementById('timeline');
            
            if (window.matchMedia("(orientation: portrait)").matches) {
                controls.style.bottom = "70px";
                controls.style.right = "15px";
                timeline.style.width = "80%";
            } else {
                controls.style.bottom = "15px";
                controls.style.right = "100px"; 
                timeline.style.width = "60%";
            }
        }
        
        window.addEventListener('orientationchange', function() {
            setTimeout(() => {
                resizeCanvas(windowWidth, windowHeight);
                repositionElements();
                updateLayoutForOrientation();
            }, 100);
        });
        
        document.getElementById('start-experience').addEventListener('click', startExperience);
        document.getElementById('start-experience').addEventListener('touchend', function(e) {
            e.preventDefault();
            startExperience();
        });
        
        document.getElementById('sound-toggle').addEventListener('click', function() {
            soundEnabled = !soundEnabled;
            
            document.getElementById('sound-waves').style.opacity = soundEnabled ? '1' : '0';
            
            if (soundEnabled && sadnessSound && !sadnessSound.isPlaying()) {
                sadnessSound.loop();
                sadnessSound.setVolume(0);
                sadnessSound.setVolume(0.4, 2);
            } else if (!soundEnabled && sadnessSound && sadnessSound.isPlaying()) {
                sadnessSound.setVolume(0, 2);
                setTimeout(() => {
                    sadnessSound.pause();
                }, 2000);
            }
        });
        
        document.getElementById('reset-button').addEventListener('click', function() {
            timePosition = 0;
            previousTimePosition = 0;
            
            resetExperience();
            updateTimelineUI();
        });
        
        document.getElementById('timeline-bar').addEventListener('mousedown', startTimelineDrag);
        document.getElementById('timeline-bar').addEventListener('touchstart', startTimelineDrag);
        
        function startTimelineDrag(e) {
            if (e.type === 'touchstart') {
                e.preventDefault();
            }
            
            isDraggingTimeline = true;
            updateTimelinePosition(e);
            
            document.addEventListener('mousemove', updateTimelinePosition);
            document.addEventListener('touchmove', updateTimelinePosition, { passive: false });
            document.addEventListener('mouseup', endTimelineDrag);
            document.addEventListener('touchend', endTimelineDrag);
        }
        
        function updateTimelinePosition(e) {
            if (!isDraggingTimeline) return;
            
            if (e.type === 'touchmove') {
                e.preventDefault();
            }
            
            const timeline = document.getElementById('timeline-bar');
            const rect = timeline.getBoundingClientRect();
            
            let clientX;
            if (e.type.startsWith('touch')) {
                clientX = e.touches[0].clientX;
            } else {
                clientX = e.clientX;
            }
            
            let percentage = (clientX - rect.left) / rect.width;
            percentage = Math.max(0, Math.min(1, percentage));
            
            document.getElementById('timeline-progress').style.width = `${percentage * 100}%`;
            document.getElementById('timeline-handle').style.left = `${percentage * 100}%`;
            
            timePosition = percentage * 45000;
            setTimePosition(timePosition);
        }
        
        function endTimelineDrag() {
            isDraggingTimeline = false;
            document.removeEventListener('mousemove', updateTimelinePosition);
            document.removeEventListener('touchmove', updateTimelinePosition);
            document.removeEventListener('mouseup', endTimelineDrag);
            document.removeEventListener('touchend', endTimelineDrag);
            
            previousTimePosition = timePosition;
        }
        
        function updateTimelineUI() {
            const percentage = timePosition / 45000;
            
            document.getElementById('timeline-progress').style.width = `${percentage * 100}%`;
            document.getElementById('timeline-handle').style.left = `${percentage * 100}%`;
        }
        
        function preload() {
            soundLoaded = false;
            sadnessSound = loadSound('sadness_soundscape.mp3', 
                function() {
                    console.log("Sound loaded successfully");
                    soundLoaded = true;
                },
                function(err) {
                    console.error("Error loading sound:", err);
                    soundEnabled = false;
                }
            );
        }

        function setup() {
            createCanvas(windowWidth, windowHeight);
            
            createHandOutline();
            createFallingElements();
            createPoolingElements();
            createWarmthElements();
            createSadnessCenters();
            
            if (getAudioContext().state !== 'running') {
                getAudioContext().resume();
            }
            
            isAnimating = false;
            noLoop();
        }
        
        function getRandomResonance() {
            return sadnessResonances[floor(random(sadnessResonances.length))];
        }
        
        function createFallingElements() {
            // Grey elements - Recognition: detecting reduced energy and withdrawal
            
            // Drifting particles - scattered, falling slowly
            for (let i = 0; i < 25; i++) {
                fallingElements.push({
                    type: 'particle',
                    x: random(width * 0.1, width * 0.9),
                    y: random(-height * 0.3, height * 0.7),
                    baseY: random(-height * 0.3, height * 0.7),
                    size: random(3, 8),
                    fallSpeed: random(0.1, 0.3),
                    driftAmount: random(0.3, 0.8),
                    driftSpeed: random(0.0005, 0.001),
                    opacity: random(80, 150),
                    startTime: 500 + i * 200,
                    visible: false,
                    interactive: random() > 0.6,
                    activated: false,
                    activatedTime: 0,
                    weight: 0,
                    maxWeight: random(60, 100),
                    weightRate: random(0.01, 0.03)
                });
            }
            
            // Dissolving forms - fragmenting shapes
            for (let i = 0; i < 8; i++) {
                fallingElements.push({
                    type: 'dissolving',
                    x: random(width * 0.2, width * 0.8),
                    y: random(height * 0.2, height * 0.6),
                    baseY: random(height * 0.2, height * 0.6),
                    size: random(30, 60),
                    fragments: floor(random(5, 12)),
                    fallSpeed: random(0.05, 0.15),
                    opacity: random(100, 180),
                    startTime: 2000 + i * 500,
                    visible: false,
                    interactive: true,
                    activated: false,
                    activatedTime: 0,
                    weight: 0,
                    maxWeight: random(70, 100),
                    weightRate: random(0.015, 0.035),
                    dissolution: 0
                });
            }
            
            // Descending lines - vertical weight indicators
            for (let i = 0; i < 6; i++) {
                fallingElements.push({
                    type: 'line',
                    x: width * (0.2 + i * 0.12),
                    y: height * 0.1,
                    length: random(height * 0.3, height * 0.5),
                    width: random(1, 2.5),
                    fallSpeed: random(0.08, 0.2),
                    opacity: random(120, 200),
                    startTime: 3500 + i * 400,
                    visible: false,
                    interactive: random() > 0.4,
                    activated: false,
                    activatedTime: 0,
                    weight: 0,
                    maxWeight: random(60, 100),
                    weightRate: random(0.02, 0.04),
                    drip: 0
                });
            }
        }
        
        function createPoolingElements() {
            // Blue undertones - Evaluation: assessing depth and duration
            
            // Pooling shapes at the bottom
            for (let i = 0; i < 5; i++) {
                poolingElements.push({
                    type: 'pool',
                    x: width * (0.15 + i * 0.18),
                    y: height * 0.85,
                    width: random(80, 150),
                    height: random(20, 40),
                    opacity: random(100, 160),
                    startTime: 6000 + i * 800,
                    visible: false,
                    interactive: true,
                    activated: false,
                    activatedTime: 0,
                    depth: 0,
                    maxDepth: random(70, 100),
                    depthRate: random(0.01, 0.025),
                    ripples: []
                });
            }
            
            // Depth layers - horizontal bands suggesting weight accumulation
            for (let i = 0; i < 4; i++) {
                poolingElements.push({
                    type: 'layer',
                    x: width * 0.1,
                    y: height * (0.7 + i * 0.07),
                    width: width * 0.8,
                    height: random(3, 8),
                    opacity: random(60, 120),
                    startTime: 8000 + i * 600,
                    visible: false,
                    interactive: random() > 0.5,
                    activated: false,
                    activatedTime: 0,
                    depth: 0,
                    maxDepth: random(50, 80),
                    depthRate: random(0.01, 0.02)
                });
            }
            
            // Settling circles - representing accumulated weight
            for (let i = 0; i < 6; i++) {
                poolingElements.push({
                    type: 'settling',
                    x: random(width * 0.2, width * 0.8),
                    y: height * (0.75 + random(0.15)),
                    radius: random(15, 35),
                    opacity: random(80, 140),
                    startTime: 10000 + i * 700,
                    visible: false,
                    interactive: true,
                    activated: false,
                    activatedTime: 0,
                    depth: 0,
                    maxDepth: random(60, 100),
                    depthRate: random(0.015, 0.03)
                });
            }
        }
        
        function createWarmthElements() {
            // Yellow hints - Response: calibrating toward gentle acknowledgment
            
            // Residual glow points - faint warmth remaining
            for (let i = 0; i < 8; i++) {
                warmthElements.push({
                    type: 'glow',
                    x: random(width * 0.15, width * 0.85),
                    y: random(height * 0.2, height * 0.7),
                    size: random(20, 45),
                    opacity: random(40, 80),
                    startTime: 12000 + i * 900,
                    visible: false,
                    interactive: true,
                    activated: false,
                    activatedTime: 0,
                    warmth: 0,
                    maxWarmth: random(50, 80),
                    warmthRate: random(0.008, 0.02),
                    pulseRate: random(0.0008, 0.0015)
                });
            }
            
            // Memory fragments - small scattered pieces of warmth
            for (let i = 0; i < 12; i++) {
                warmthElements.push({
                    type: 'fragment',
                    x: random(width * 0.1, width * 0.9),
                    y: random(height * 0.15, height * 0.75),
                    size: random(4, 10),
                    opacity: random(50, 100),
                    startTime: 14000 + i * 500,
                    visible: false,
                    interactive: random() > 0.5,
                    activated: false,
                    activatedTime: 0,
                    warmth: 0,
                    maxWarmth: random(40, 70),
                    warmthRate: random(0.01, 0.025),
                    drift: random(TWO_PI)
                });
            }
            
            // Horizon line - distant hope
            warmthElements.push({
                type: 'horizon',
                x: width * 0.1,
                y: height * 0.35,
                width: width * 0.8,
                opacity: 50,
                startTime: 16000,
                visible: false,
                interactive: true,
                activated: false,
                activatedTime: 0,
                warmth: 0,
                maxWarmth: 60,
                warmthRate: 0.01
            });
        }

        function createHandOutline() {
            // Hand reaching downward - representing the weight of sadness
            
            // Wrist area
            handOutlinePoints.push({x: 0.45, y: 0.35});
            handOutlinePoints.push({x: 0.55, y: 0.35});
            
            // Right side of hand flowing down
            handOutlinePoints.push({x: 0.58, y: 0.42});
            handOutlinePoints.push({x: 0.60, y: 0.50});
            handOutlinePoints.push({x: 0.58, y: 0.58});
            
            // Fingers drooping downward
            handOutlinePoints.push({x: 0.56, y: 0.65});
            handOutlinePoints.push({x: 0.54, y: 0.70});
            handOutlinePoints.push({x: 0.52, y: 0.73});
            
            // Middle fingers
            handOutlinePoints.push({x: 0.50, y: 0.75});
            handOutlinePoints.push({x: 0.48, y: 0.73});
            handOutlinePoints.push({x: 0.46, y: 0.70});
            
            // Left fingers
            handOutlinePoints.push({x: 0.44, y: 0.65});
            handOutlinePoints.push({x: 0.42, y: 0.58});
            handOutlinePoints.push({x: 0.40, y: 0.50});
            handOutlinePoints.push({x: 0.42, y: 0.42});
            
            // Back to wrist
            handOutlinePoints.push({x: 0.45, y: 0.35});
            
            // Convert to absolute coordinates
            for (let i = 0; i < handOutlinePoints.length; i++) {
                handOutlinePoints[i].x *= width;
                handOutlinePoints[i].y *= height;
            }
        }
        
        function createSadnessCenters() {
            // Main center - the heart of the weight
            sadnessCenters.push({
                x: width * 0.5, 
                y: height * 0.55,
                size: 90,
                opacity: 0,
                targetOpacity: 120,
                pulseRate: 0.0008,
                activated: false,
                activationProgress: 0,
                startTime: 18000,
                resonance: "The quiet center where weight accumulates",
                elements: []
            });
            
            // Secondary centers
            for (let i = 0; i < 2; i++) {
                sadnessCenters.push({
                    x: random(width * 0.25, width * 0.75),
                    y: random(height * 0.4, height * 0.7),
                    size: random(50, 70),
                    opacity: 0,
                    targetOpacity: random(80, 120),
                    pulseRate: random(0.0006, 0.001),
                    activated: false,
                    activationProgress: 0,
                    startTime: 22000 + i * 4000,
                    resonance: getRandomResonance(),
                    elements: []
                });
            }
            
            // Assign elements to centers
            for (let i = 0; i < fallingElements.length; i++) {
                let elem = fallingElements[i];
                
                for (let j = 0; j < sadnessCenters.length; j++) {
                    let d = dist(elem.x, elem.y, sadnessCenters[j].x, sadnessCenters[j].y);
                    if (d < 180) {
                        sadnessCenters[j].elements.push({type: 'falling', index: i});
                        break;
                    }
                }
            }
            
            for (let i = 0; i < poolingElements.length; i++) {
                let elem = poolingElements[i];
                
                for (let j = 0; j < sadnessCenters.length; j++) {
                    let d = dist(elem.x, elem.y, sadnessCenters[j].x, sadnessCenters[j].y);
                    if (d < 200) {
                        sadnessCenters[j].elements.push({type: 'pooling', index: i});
                        break;
                    }
                }
            }
            
            for (let i = 0; i < warmthElements.length; i++) {
                let elem = warmthElements[i];
                
                for (let j = 0; j < sadnessCenters.length; j++) {
                    let d = dist(elem.x, elem.y, sadnessCenters[j].x, sadnessCenters[j].y);
                    if (d < 160) {
                        sadnessCenters[j].elements.push({type: 'warmth', index: i});
                        break;
                    }
                }
            }
        }

        function draw() {
            // Soft grey-blue background suggesting muted emotional landscape
            background(240, 240, 238);
            
            if (isAnimating && !isDraggingTimeline) {
                timePosition += deltaTime * 0.7; // Slower pace for sadness
                
                if (timePosition > 45000) {
                    timePosition = 45000;
                    
                    if (!activatedTimeline) {
                        showTimeline();
                        activatedTimeline = true;
                    }
                }
                
                updateTimelineUI();
                previousTimePosition = timePosition;
            }

            weightPhase += weightRate * deltaTime * 0.001;
            
            // Draw layers in order: warmth (back), pooling (middle), falling (front)
            drawWarmthElements();
            drawPoolingElements();
            drawFallingElements();
            drawHandOutline();
            drawSadnessCenters();
            
            // Update hand progress - slower for sadness
            if (isAnimating) {
                handProgress = min(1, handProgress + 0.0002);
            }
            
            updateActivatedElements();
            updateElementPropagation();
        }
        
        function showTimeline() {
            document.getElementById('timeline').style.opacity = '1';
            updateLayoutForOrientation();
        }
        
        function updateActivatedElements() {
            for (let elem of fallingElements) {
                if (elem.activated) {
                    if (elem.weight > 0) {
                        elem.weight = max(0, elem.weight - 0.15);
                    }
                    
                    if (millis() - elem.activatedTime > 5000) {
                        elem.activated = false;
                    }
                }
            }
            
            for (let elem of poolingElements) {
                if (elem.activated) {
                    if (elem.depth > 0) {
                        elem.depth = max(0, elem.depth - 0.12);
                    }
                    
                    if (millis() - elem.activatedTime > 5000) {
                        elem.activated = false;
                    }
                }
            }
            
            for (let elem of warmthElements) {
                if (elem.activated) {
                    if (elem.warmth > 0) {
                        elem.warmth = max(0, elem.warmth - 0.1);
                    }
                    
                    if (millis() - elem.activatedTime > 6000) {
                        elem.activated = false;
                    }
                }
            }
            
            for (let center of sadnessCenters) {
                if (center.activated) {
                    center.activationProgress = min(1, center.activationProgress + 0.005);
                }
            }
            
            if (activeSadnessCenter !== null && !sadnessCenters[activeSadnessCenter].activated) {
                if (sadnessCenters[activeSadnessCenter].activationProgress > 0) {
                    sadnessCenters[activeSadnessCenter].activationProgress = max(0, sadnessCenters[activeSadnessCenter].activationProgress - 0.008);
                } else {
                    activeSadnessCenter = null;
                    centerActivated = false;
                }
            }
        }
        
        function updateElementPropagation() {
            // Sadness spreads slowly, heavily, from falling to pooling
            for (let i = 0; i < fallingElements.length; i++) {
                let falling = fallingElements[i];
                
                if (falling.activated && falling.weight > 20) {
                    for (let j = 0; j < poolingElements.length; j++) {
                        let pooling = poolingElements[j];
                        let d = dist(falling.x, falling.y, pooling.x, pooling.y);
                        
                        if (d < 200) {
                            let depthTransfer = max(0, falling.weight * (1 - d/200) * 0.08);
                            pooling.depth = min(pooling.maxDepth, pooling.depth + depthTransfer);
                            
                            if (pooling.depth > 15 && !pooling.activated) {
                                pooling.activated = true;
                                pooling.activatedTime = millis();
                            }
                        }
                    }
                }
            }
            
            // Pooling can dim warmth elements nearby
            for (let i = 0; i < poolingElements.length; i++) {
                let pooling = poolingElements[i];
                
                if (pooling.activated && pooling.depth > 25) {
                    for (let j = 0; j < warmthElements.length; j++) {
                        let warmth = warmthElements[j];
                        let d = dist(pooling.x, pooling.y, warmth.x, warmth.y);
                        
                        if (d < 180) {
                            // Warmth slowly diminishes near deep sadness
                            warmth.warmth = max(0, warmth.warmth - 0.02 * pooling.depth / pooling.maxDepth);
                        }
                    }
                }
            }
        }
        
        function setTimePosition(time) {
            const previousMillis = previousTimePosition;
            const timeDiff = time - previousMillis;
            
            if (timeDiff < -2000) {
                resetExperience();
            }
        }
        
        function resetExperience() {
            for (let elem of fallingElements) {
                elem.visible = timePosition > elem.startTime;
                elem.activated = false;
                elem.weight = 0;
                elem.y = elem.baseY;
                if (elem.type === 'dissolving') elem.dissolution = 0;
                if (elem.type === 'line') elem.drip = 0;
            }
            
            for (let elem of poolingElements) {
                elem.visible = timePosition > elem.startTime;
                elem.activated = false;
                elem.depth = 0;
                if (elem.type === 'pool') elem.ripples = [];
            }
            
            for (let elem of warmthElements) {
                elem.visible = timePosition > elem.startTime;
                elem.activated = false;
                elem.warmth = 0;
            }
            
            for (let center of sadnessCenters) {
                center.opacity = timePosition > center.startTime ? center.targetOpacity : 0;
                center.activated = false;
                center.activationProgress = 0;
            }
            
            handProgress = min(1, timePosition / 30000);
            activeSadnessCenter = null;
            centerActivated = false;
        }

        function drawHandOutline() {
            if (timePosition < 12000) return;
            
            let pointsToShow = floor(handOutlinePoints.length * handProgress);
            
            if (pointsToShow < 2) return;
            
            noFill();
            stroke(colors.greyDark[0], colors.greyDark[1], colors.greyDark[2], 80);
            strokeWeight(1.2);
            
            beginShape();
            for (let i = 0; i < pointsToShow; i++) {
                // Add slight downward drift to suggest weight
                let driftY = sin(millis() * 0.0003 + i * 0.2) * 2;
                vertex(handOutlinePoints[i].x, handOutlinePoints[i].y + driftY);
            }
            endShape(pointsToShow === handOutlinePoints.length ? CLOSE : OPEN);
            
            if (pointsToShow === handOutlinePoints.length) {
                // Palm details - heavier, more weighted lines
                stroke(colors.greyDark[0], colors.greyDark[1], colors.greyDark[2], 50);
                strokeWeight(0.8);
                
                // Weight lines descending
                let palmCenterX = (handOutlinePoints[0].x + handOutlinePoints[8].x) / 2;
                let palmCenterY = (handOutlinePoints[0].y + handOutlinePoints[8].y) / 2;
                
                for (let i = 0; i < 3; i++) {
                    let startY = palmCenterY - 15 + i * 10;
                    let endY = startY + 20 + sin(millis() * 0.0005) * 5;
                    
                    line(palmCenterX - 10 + i * 10, startY, palmCenterX - 10 + i * 10, endY);
                }
                
                // Add sadness symbol when center is active
                if (activeSadnessCenter !== null && sadnessCenters[activeSadnessCenter].activationProgress > 0.5) {
                    let progress = sadnessCenters[activeSadnessCenter].activationProgress;
                    
                    push();
                    translate(palmCenterX, palmCenterY);
                    
                    // Downward-pointing teardrop shape
                    noFill();
                    stroke(colors.blue[0], colors.blue[1], colors.blue[2], 100 * progress);
                    strokeWeight(1);
                    
                    beginShape();
                    for (let a = 0; a <= TWO_PI; a += 0.1) {
                        let r = 12 * progress * (1 + 0.3 * sin(a * 2 - HALF_PI));
                        vertex(cos(a) * r * 0.7, sin(a) * r);
                    }
                    endShape(CLOSE);
                    
                    // Falling droplet inside
                    fill(colors.blue[0], colors.blue[1], colors.blue[2], 80 * progress);
                    noStroke();
                    let dropY = 5 + sin(millis() * 0.001) * 3;
                    ellipse(0, dropY, 4 * progress, 6 * progress);
                    
                    pop();
                }
            }
        }
        
        function drawFallingElements() {
            for (let elem of fallingElements) {
                if (timePosition > elem.startTime) {
                    elem.visible = true;
                }
                
                if (!elem.visible) continue;
                
                // Update falling position
                if (isAnimating) {
                    elem.y += elem.fallSpeed * (1 + elem.weight / elem.maxWeight * 0.5);
                    
                    // Reset when fallen off screen
                    if (elem.y > height + 50) {
                        elem.y = -50;
                    }
                }
                
                let weightFactor = elem.weight / elem.maxWeight;
                
                if (elem.type === 'particle') {
                    drawFallingParticle(elem, weightFactor);
                } else if (elem.type === 'dissolving') {
                    drawDissolvingForm(elem, weightFactor);
                } else if (elem.type === 'line') {
                    drawFallingLine(elem, weightFactor);
                }
            }
        }
        
        function drawFallingParticle(elem, weightFactor) {
            let drift = sin(millis() * elem.driftSpeed + elem.x * 0.01) * elem.driftAmount * 20;
            let x = elem.x + drift;
            
            // Darker and larger when weighted
            let opacity = elem.opacity * (0.6 + weightFactor * 0.4);
            let size = elem.size * (1 + weightFactor * 0.5);
            
            noStroke();
            fill(colors.grey[0], colors.grey[1], colors.grey[2], opacity);
            ellipse(x, elem.y, size, size * (1 + weightFactor * 0.3)); // Elongate when heavy
            
            // Trail when falling with weight
            if (weightFactor > 0.2) {
                for (let i = 1; i <= 3; i++) {
                    let trailOpacity = opacity * 0.3 * (1 - i/4);
                    fill(colors.grey[0], colors.grey[1], colors.grey[2], trailOpacity);
                    ellipse(x, elem.y - i * 8, size * 0.6, size * 0.4);
                }
            }
            
            // Interactive pulse
            if (elem.interactive && !elem.activated) {
                noFill();
                stroke(colors.grey[0], colors.grey[1], colors.grey[2], 30);
                strokeWeight(0.5);
                ellipse(x, elem.y, size + 8 + sin(millis() * 0.001) * 3);
            }
        }
        
        function drawDissolvingForm(elem, weightFactor) {
            push();
            translate(elem.x, elem.y);
            
            // Update dissolution
            if (isAnimating && elem.activated) {
                elem.dissolution = min(1, elem.dissolution + 0.003);
            }
            
            let opacity = elem.opacity * (0.5 + weightFactor * 0.5);
            
            // Draw fragments spreading apart
            for (let i = 0; i < elem.fragments; i++) {
                let angle = TWO_PI * i / elem.fragments;
                let baseRadius = elem.size * 0.3;
                let spreadRadius = baseRadius + elem.dissolution * elem.size * 0.5;
                
                // Add weight-based downward pull
                let yOffset = weightFactor * 10 + elem.dissolution * 15;
                
                let x = cos(angle) * spreadRadius;
                let y = sin(angle) * spreadRadius + yOffset;
                
                let fragSize = (elem.size / elem.fragments) * (1 - elem.dissolution * 0.5);
                
                noStroke();
                fill(colors.grey[0], colors.grey[1], colors.grey[2], opacity * (1 - elem.dissolution * 0.3));
                ellipse(x, y, fragSize, fragSize);
            }
            
            // Central form, fading
            fill(colors.greyDark[0], colors.greyDark[1], colors.greyDark[2], opacity * (1 - elem.dissolution));
            ellipse(0, weightFactor * 5, elem.size * 0.4 * (1 - elem.dissolution * 0.7));
            
            pop();
            
            if (elem.interactive && !elem.activated) {
                noFill();
                stroke(colors.grey[0], colors.grey[1], colors.grey[2], 25);
                strokeWeight(0.5);
                ellipse(elem.x, elem.y, elem.size + 15 + sin(millis() * 0.001) * 4);
            }
        }
        
        function drawFallingLine(elem, weightFactor) {
            let opacity = elem.opacity * (0.6 + weightFactor * 0.4);
            let lineWeight = elem.width * (1 + weightFactor * 0.5);
            
            stroke(colors.greyDark[0], colors.greyDark[1], colors.greyDark[2], opacity);
            strokeWeight(lineWeight);
            
            // Main descending line
            line(elem.x, elem.y, elem.x, elem.y + elem.length);
            
            // Dripping effect when weighted
            if (weightFactor > 0.3) {
                if (isAnimating) {
                    elem.drip = (elem.drip + 0.02 * weightFactor) % 1;
                }
                
                let dripY = elem.y + elem.length + elem.drip * 30;
                let dripSize = 4 * weightFactor * (1 - elem.drip);
                
                noStroke();
                fill(colors.greyDark[0], colors.greyDark[1], colors.greyDark[2], opacity * (1 - elem.drip));
                ellipse(elem.x, dripY, dripSize, dripSize * 1.5);
            }
            
            if (elem.interactive && !elem.activated) {
                noFill();
                stroke(colors.grey[0], colors.grey[1], colors.grey[2], 25);
                strokeWeight(0.5);
                let midY = elem.y + elem.length / 2;
                ellipse(elem.x, midY, 12 + sin(millis() * 0.001) * 3);
            }
        }
        
        function drawPoolingElements() {
            for (let elem of poolingElements) {
                if (timePosition > elem.startTime) {
                    elem.visible = true;
                }
                
                if (!elem.visible) continue;
                
                let depthFactor = elem.depth / elem.maxDepth;
                
                if (elem.type === 'pool') {
                    drawPool(elem, depthFactor);
                } else if (elem.type === 'layer') {
                    drawLayer(elem, depthFactor);
                } else if (elem.type === 'settling') {
                    drawSettling(elem, depthFactor);
                }
            }
        }
        
        function drawPool(elem, depthFactor) {
            let opacity = elem.opacity * (0.5 + depthFactor * 0.5);
            
            // Pool shape - elliptical, deeper blue when more depth
            noStroke();
            
            // Outer glow
            let glowOpacity = opacity * 0.3;
            for (let i = 3; i >= 0; i--) {
                fill(colors.blue[0], colors.blue[1], colors.blue[2], glowOpacity * (1 - i/4));
                ellipse(elem.x, elem.y, elem.width + i * 15, elem.height + i * 8);
            }
            
            // Main pool
            fill(colors.blue[0], colors.blue[1], colors.blue[2], opacity);
            ellipse(elem.x, elem.y, elem.width, elem.height * (1 + depthFactor * 0.3));
            
            // Darker center for depth
            fill(colors.greyDark[0], colors.greyDark[1], colors.greyDark[2], opacity * 0.4 * depthFactor);
            ellipse(elem.x, elem.y, elem.width * 0.5, elem.height * 0.4);
            
            // Ripples when activated
            if (depthFactor > 0.2) {
                noFill();
                stroke(colors.blueLight[0], colors.blueLight[1], colors.blueLight[2], opacity * 0.4);
                strokeWeight(0.8);
                
                let rippleRadius = elem.width * 0.3 + sin(millis() * 0.001) * 10;
                ellipse(elem.x, elem.y, rippleRadius, rippleRadius * 0.4);
            }
            
            if (elem.interactive && !elem.activated) {
                noFill();
                stroke(colors.blue[0], colors.blue[1], colors.blue[2], 30);
                strokeWeight(0.5);
                ellipse(elem.x, elem.y, elem.width + 20 + sin(millis() * 0.0008) * 5, elem.height + 12);
            }
        }
        
        function drawLayer(elem, depthFactor) {
            let opacity = elem.opacity * (0.5 + depthFactor * 0.5);
            
            noStroke();
            fill(colors.blue[0], colors.blue[1], colors.blue[2], opacity);
            
            // Horizontal band with slight wave
            beginShape();
            for (let x = elem.x; x <= elem.x + elem.width; x += 10) {
                let waveY = sin((x - elem.x) * 0.02 + millis() * 0.0005) * 2 * (1 + depthFactor);
                vertex(x, elem.y + waveY);
            }
            for (let x = elem.x + elem.width; x >= elem.x; x -= 10) {
                let waveY = sin((x - elem.x) * 0.02 + millis() * 0.0005) * 2 * (1 + depthFactor);
                vertex(x, elem.y + elem.height + waveY);
            }
            endShape(CLOSE);
            
            if (elem.interactive && !elem.activated) {
                stroke(colors.blue[0], colors.blue[1], colors.blue[2], 25);
                strokeWeight(0.5);
                noFill();
                rect(elem.x - 5, elem.y - 5, elem.width + 10, elem.height + 10, 3);
            }
        }
        
        function drawSettling(elem, depthFactor) {
            let opacity = elem.opacity * (0.5 + depthFactor * 0.5);
            
            noStroke();
            
            // Outer settling ring
            fill(colors.blueLight[0], colors.blueLight[1], colors.blueLight[2], opacity * 0.5);
            ellipse(elem.x, elem.y, elem.radius * 2 * (1 + depthFactor * 0.2));
            
            // Inner concentrated weight
            fill(colors.blue[0], colors.blue[1], colors.blue[2], opacity);
            ellipse(elem.x, elem.y, elem.radius * (1 + depthFactor * 0.3));
            
            // Core
            fill(colors.greyDark[0], colors.greyDark[1], colors.greyDark[2], opacity * 0.6 * depthFactor);
            ellipse(elem.x, elem.y, elem.radius * 0.4);
            
            if (elem.interactive && !elem.activated) {
                noFill();
                stroke(colors.blue[0], colors.blue[1], colors.blue[2], 25);
                strokeWeight(0.5);
                ellipse(elem.x, elem.y, elem.radius * 2 + 15 + sin(millis() * 0.0008) * 4);
            }
        }
        
        function drawWarmthElements() {
            for (let elem of warmthElements) {
                if (timePosition > elem.startTime) {
                    elem.visible = true;
                }
                
                if (!elem.visible) continue;
                
                let warmthFactor = elem.warmth / elem.maxWarmth;
                
                if (elem.type === 'glow') {
                    drawGlow(elem, warmthFactor);
                } else if (elem.type === 'fragment') {
                    drawFragment(elem, warmthFactor);
                } else if (elem.type === 'horizon') {
                    drawHorizon(elem, warmthFactor);
                }
            }
        }
        
        function drawGlow(elem, warmthFactor) {
            let baseOpacity = elem.opacity * (0.5 + warmthFactor * 0.5);
            let pulse = sin(millis() * elem.pulseRate) * 0.15;
            let size = elem.size * (1 + pulse);
            
            noStroke();
            
            // Soft outer glow
            for (let i = 4; i >= 0; i--) {
                let layerOpacity = baseOpacity * 0.2 * (1 - i/5);
                fill(colors.yellow[0], colors.yellow[1], colors.yellow[2], layerOpacity);
                ellipse(elem.x, elem.y, size + i * 15, size + i * 15);
            }
            
            // Core warmth
            fill(colors.yellowLight[0], colors.yellowLight[1], colors.yellowLight[2], baseOpacity);
            ellipse(elem.x, elem.y, size * 0.5, size * 0.5);
            
            if (elem.interactive && !elem.activated) {
                noFill();
                stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], 25);
                strokeWeight(0.5);
                ellipse(elem.x, elem.y, size + 20 + sin(millis() * 0.001) * 4);
            }
        }
        
        function drawFragment(elem, warmthFactor) {
            let opacity = elem.opacity * (0.4 + warmthFactor * 0.6);
            
            // Gentle drift
            let driftX = sin(millis() * 0.0003 + elem.drift) * 3;
            let driftY = cos(millis() * 0.0004 + elem.drift) * 2;
            
            noStroke();
            fill(colors.yellow[0], colors.yellow[1], colors.yellow[2], opacity);
            ellipse(elem.x + driftX, elem.y + driftY, elem.size, elem.size);
            
            // Tiny sparkle
            if (warmthFactor > 0.3) {
                fill(colors.yellowLight[0], colors.yellowLight[1], colors.yellowLight[2], opacity * 0.8);
                ellipse(elem.x + driftX, elem.y + driftY, elem.size * 0.4);
            }
            
            if (elem.interactive && !elem.activated) {
                noFill();
                stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], 20);
                strokeWeight(0.4);
                ellipse(elem.x + driftX, elem.y + driftY, elem.size + 8 + sin(millis() * 0.001) * 2);
            }
        }
        
        function drawHorizon(elem, warmthFactor) {
            let opacity = elem.opacity * (0.4 + warmthFactor * 0.6);
            
            stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], opacity);
            strokeWeight(1 + warmthFactor);
            
            // Gentle wave in the horizon line
            beginShape();
            for (let x = elem.x; x <= elem.x + elem.width; x += 5) {
                let waveY = sin((x - elem.x) * 0.01 + millis() * 0.0003) * 3;
                vertex(x, elem.y + waveY);
            }
            endShape();
            
            // Glow above horizon
            noStroke();
            for (let i = 0; i < 3; i++) {
                fill(colors.yellowLight[0], colors.yellowLight[1], colors.yellowLight[2], opacity * 0.15 * (1 - i/3));
                rect(elem.x, elem.y - 20 - i * 10, elem.width, 15);
            }
            
            if (elem.interactive && !elem.activated) {
                stroke(colors.yellow[0], colors.yellow[1], colors.yellow[2], 20);
                strokeWeight(0.5);
                noFill();
                rect(elem.x - 5, elem.y - 30, elem.width + 10, 50, 3);
            }
        }
        
        function drawSadnessCenters() {
            for (let i = 0; i < sadnessCenters.length; i++) {
                let center = sadnessCenters[i];
                
                if (timePosition > center.startTime) {
                    if (center.opacity < center.targetOpacity) {
                        center.opacity = min(center.targetOpacity, center.opacity + 0.5);
                    }
                    
                    let pulse = sin(millis() * center.pulseRate) * 0.1;
                    let size = center.size * (1 + pulse);
                    
                    // Active center effects
                    if (i === activeSadnessCenter && center.activationProgress > 0) {
                        // Expanding weight rings
                        for (let j = 0; j < 3; j++) {
                            let ringSize = size + j * 25 * center.activationProgress;
                            let ringOpacity = (60 - j * 15) * center.activationProgress;
                            
                            noFill();
                            stroke(colors.blue[0], colors.blue[1], colors.blue[2], ringOpacity);
                            strokeWeight(1.5 - j * 0.4);
                            ellipse(center.x, center.y, ringSize);
                        }
                        
                        // Downward rays for weight
                        stroke(colors.grey[0], colors.grey[1], colors.grey[2], 50 * center.activationProgress);
                        strokeWeight(0.8);
                        
                        for (let j = 0; j < 5; j++) {
                            let rayX = center.x - 20 + j * 10;
                            let rayLength = 30 + sin(millis() * 0.001 + j) * 10;
                            line(rayX, center.y, rayX, center.y + rayLength * center.activationProgress);
                        }
                    }
                    
                    // Main center boundary
                    noFill();
                    stroke(colors.blue[0], colors.blue[1], colors.blue[2], center.opacity);
                    strokeWeight(1.5);
                    ellipse(center.x, center.y, size);
                    
                    // Inner weight indicator
                    fill(colors.blue[0], colors.blue[1], colors.blue[2], center.opacity * 0.15);
                    noStroke();
                    ellipse(center.x, center.y, size * 0.5);
                    
                    // Interactive hint
                    if (!center.activated) {
                        fill(colors.grey[0], colors.grey[1], colors.grey[2], 50 + 20 * sin(millis() * 0.002));
                        noStroke();
                        
                        // Downward arrow/teardrop shape
                        push();
                        translate(center.x, center.y);
                        
                        beginShape();
                        vertex(0, -8);
                        vertex(6, 0);
                        vertex(0, 12);
                        vertex(-6, 0);
                        endShape(CLOSE);
                        
                        pop();
                    }
                }
            }
        }
        
        function showSadnessResonance(message, x, y) {
            const resonance = document.getElementById('sadness-resonance');
            resonance.innerHTML = message;
            
            let posX = x;
            let posY = y - 70;
            
            if (posX < 20) posX = 20;
            if (posX > window.innerWidth - 270) posX = window.innerWidth - 270;
            if (posY < 20) posY = 20;
            if (posY > window.innerHeight - 100) posY = window.innerHeight - 100;
            
            resonance.style.left = posX + 'px';
            resonance.style.top = posY + 'px';
            resonance.style.transform = 'translateY(0)';
            resonance.style.opacity = '1';
            
            setTimeout(() => {
                resonance.style.opacity = '0';
                resonance.style.transform = 'translateY(20px)';
            }, 5000);
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            repositionElements();
            updateLayoutForOrientation();
        }
        
        function repositionElements() {
            for (let i = 0; i < handOutlinePoints.length; i++) {
                handOutlinePoints[i].x = (handOutlinePoints[i].x / width) * windowWidth;
                handOutlinePoints[i].y = (handOutlinePoints[i].y / height) * windowHeight;
            }
            
            for (let elem of fallingElements) {
                elem.x = (elem.x / width) * windowWidth;
                elem.y = (elem.y / height) * windowHeight;
                elem.baseY = (elem.baseY / height) * windowHeight;
                if (elem.type === 'dissolving') elem.size = (elem.size / width) * windowWidth;
                if (elem.type === 'line') elem.length = (elem.length / height) * windowHeight;
            }
            
            for (let elem of poolingElements) {
                elem.x = (elem.x / width) * windowWidth;
                elem.y = (elem.y / height) * windowHeight;
                if (elem.type === 'pool') {
                    elem.width = (elem.width / width) * windowWidth;
                }
                if (elem.type === 'layer') {
                    elem.width = (elem.width / width) * windowWidth;
                }
                if (elem.type === 'settling') {
                    elem.radius = (elem.radius / width) * windowWidth;
                }
            }
            
            for (let elem of warmthElements) {
                elem.x = (elem.x / width) * windowWidth;
                elem.y = (elem.y / height) * windowHeight;
                if (elem.type === 'horizon') {
                    elem.width = (elem.width / width) * windowWidth;
                }
            }
            
            for (let center of sadnessCenters) {
                center.x = (center.x / width) * windowWidth;
                center.y = (center.y / height) * windowHeight;
                center.size = (center.size / width) * windowWidth;
            }
        }
        
        function mousePressed() {
            if (document.getElementById('landing-overlay').style.display === 'none') {
                
                // Check sadness centers
                for (let i = 0; i < sadnessCenters.length; i++) {
                    let center = sadnessCenters[i];
                    
                    if (timePosition > center.startTime) {
                        let d = dist(mouseX, mouseY, center.x, center.y);
                        
                        if (d < center.size / 2) {
                            center.activated = !center.activated;
                            
                            if (center.activated) {
                                activeSadnessCenter = i;
                                centerActivated = true;
                                
                                showSadnessResonance(center.resonance, center.x, center.y);
                                
                                for (let element of center.elements) {
                                    if (element.type === 'falling') {
                                        fallingElements[element.index].activated = true;
                                        fallingElements[element.index].activatedTime = millis();
                                        fallingElements[element.index].weight = fallingElements[element.index].maxWeight * 0.7;
                                    } else if (element.type === 'pooling') {
                                        poolingElements[element.index].activated = true;
                                        poolingElements[element.index].activatedTime = millis();
                                        poolingElements[element.index].depth = poolingElements[element.index].maxDepth * 0.8;
                                    } else {
                                        warmthElements[element.index].activated = true;
                                        warmthElements[element.index].activatedTime = millis();
                                        warmthElements[element.index].warmth = warmthElements[element.index].maxWarmth * 0.6;
                                    }
                                }
                            } else {
                                activeSadnessCenter = null;
                                centerActivated = false;
                            }
                            
                            return false;
                        }
                    }
                }
                
                // Check falling elements
                for (let elem of fallingElements) {
                    if (elem.visible && elem.interactive) {
                        let hitTest = false;
                        let testSize = elem.type === 'line' ? elem.length / 2 : elem.size;
                        
                        let d = dist(mouseX, mouseY, elem.x, elem.y);
                        hitTest = (d < testSize + 15);
                        
                        if (hitTest) {
                            elem.activated = !elem.activated;
                            elem.activatedTime = millis();
                            
                            if (elem.activated) {
                                elem.weight = elem.maxWeight * 0.7;
                                showSadnessResonance(getRandomResonance(), elem.x, elem.y);
                            }
                            
                            return false;
                        }
                    }
                }
                
                // Check pooling elements
                for (let elem of poolingElements) {
                    if (elem.visible && elem.interactive) {
                        let hitTest = false;
                        let testSize = elem.type === 'pool' ? elem.width / 2 : 
                                       elem.type === 'settling' ? elem.radius : elem.height;
                        
                        let d = dist(mouseX, mouseY, elem.x, elem.y);
                        hitTest = (d < testSize + 20);
                        
                        if (hitTest) {
                            elem.activated = !elem.activated;
                            elem.activatedTime = millis();
                            
                            if (elem.activated) {
                                elem.depth = elem.maxDepth * 0.8;
                                showSadnessResonance(getRandomResonance(), elem.x, elem.y);
                            }
                            
                            return false;
                        }
                    }
                }
                
                // Check warmth elements
                for (let elem of warmthElements) {
                    if (elem.visible && elem.interactive) {
                        let hitTest = false;
                        let testSize = elem.type === 'glow' ? elem.size : 
                                       elem.type === 'horizon' ? 30 : elem.size + 5;
                        
                        let d = dist(mouseX, mouseY, elem.x, elem.y);
                        hitTest = (d < testSize + 15);
                        
                        if (hitTest) {
                            elem.activated = !elem.activated;
                            elem.activatedTime = millis();
                            
                            if (elem.activated) {
                                elem.warmth = elem.maxWarmth * 0.6;
                                showSadnessResonance(getRandomResonance(), elem.x, elem.y);
                            }
                            
                            return false;
                        }
                    }
                }
                
                // Toggle animation
                isAnimating = !isAnimating;
                
                if (!isAnimating && soundEnabled && soundLoaded && sadnessSound.isPlaying()) {
                    sadnessSound.setVolume(0.2, 1.5);
                } else if (isAnimating && soundEnabled && soundLoaded) {
                    sadnessSound.setVolume(0.4, 1.5);
                }
            }
            
            return false;
        }
        
        function touchStarted() {
            if (getAudioContext().state !== 'running') {
                getAudioContext().resume();
            }
            
            return mousePressed();
        }
    </script>
</body>
</html>
